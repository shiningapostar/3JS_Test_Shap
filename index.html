<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Box Model Editor</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
      }
      #scene-container {
        height: 100vh !important;
      }
      #container {
        display: flex;
      }
      #container #layout-container {
        padding: 40px;
        overflow-y: auto;
      }
      .section-box {
        margin-bottom: 20px;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.148.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <div id="container">
      <div
        id="scene-container"
        style="width: 50% !important; height: 100%"
      ></div>
      <div id="layout-container" style="width: 50% !important; height: 100%">
        <div class="section-box">
          <h2>Dimensions</h2>
          <div class="input-group">
            <input
              type="number"
              id="model-width"
              placeholder="Width"
              value="600"
              min="300"
              max="1524"
              class="form-control"
            />
            <input
              type="number"
              id="model-length"
              placeholder="Length"
              value="1500"
              min="300"
              max="2743"
              class="form-control"
            />
            <select id="model-thickness" class="form-select">
              <option value="25.4">25.4mm</option>
              <option value="15.875">15.875mm</option>
              <option value="100">100mm</option>
              <option value="200">200mm</option>
              <option value="300">300mm</option>
            </select>
          </div>
        </div>
        <div class="section-box">
          <h2>Moulding</h2>
          <div id="mouldings-container"></div>
          <div class="mt-2 text-end">
            <button
              type="button"
              class="btn btn-sm btn-primary"
              id="add-moulding-btn"
            >
              Add Moulding
            </button>
          </div>
        </div>
        <div class="section-box">
          <h2>Edge Banding</h2>
          <div class="input-group">
            <select
              class="form-select"
              id="top-select"
              onchange="BoxModel.updateFaceTexture('top',this.value);"
            >
              <option value="/pb.jpg">None</option>
              <option value="/walnut.jpg">Walnut</option>
            </select>
            <select
              class="form-select"
              id="right-select"
              onchange="BoxModel.updateFaceTexture('right',this.value);"
            >
              <option value="/pb.jpg">None</option>
              <option value="/walnut.jpg">Walnut</option>
            </select>
            <select
              class="form-select"
              id="bottom-select"
              onchange="BoxModel.updateFaceTexture('bottom',this.value);"
            >
              <option value="/pb.jpg">None</option>
              <option value="/walnut.jpg">Walnut</option>
            </select>
            <select
              class="form-select"
              id="left-select"
              onchange="BoxModel.updateFaceTexture('left',this.value);"
            >
              <option value="/pb.jpg">None</option>
              <option value="/walnut.jpg">Walnut</option>
            </select>
          </div>
        </div>
        <div class="section-box">
          <h2>Cutout Holes</h2>
          <div id="cutouts-container"></div>
          <div class="mt-2 text-end">
            <button
              type="button"
              class="btn btn-sm btn-primary"
              id="add-cutout-btn"
            >
              Add Cutout
            </button>
          </div>
          <input
            type="hidden"
            name="cutout_holes_data"
            id="cutout-holes-data"
          />
        </div>
        <div class="section-box">
          <h2>Bevel Cut</h2>
          <div id="bevels-container"></div>
          <div class="mt-2 text-end">
            <button
              type="button"
              class="btn btn-sm btn-primary"
              id="add-bevelcut-btn"
            >
              Add Cutout
            </button>
          </div>
        </div>
        <div class="section-box">
          <h2>Mitre Cut</h2>
          <div id="mitre-cut-container"></div>
          <div class="mt-2 text-end">
            <button
              type="button"
              class="btn btn-sm btn-primary"
              id="add-mitrecut-btn"
            >
              Add Cutout
            </button>
          </div>
        </div>
        <div class="section-box">
          <h2>Corners</h2>
          <div id="corners-container"></div>
          <div class="mt-2 text-end">
            <button
              type="button"
              class="btn btn-sm btn-primary"
              id="add-corner-btn"
            >
              Add Corner
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- External Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import * as threeBvhCsg from "https://cdn.jsdelivr.net/npm/three-bvh-csg@0.0.16/+esm";

      let csgEvaluator = new threeBvhCsg.Evaluator();
      csgEvaluator.useGroup = true;

      // Create a global model module using an immediately invoked function expression (IIFE)
      const BoxModel = (function () {
        // Private variables
        let scene, camera, renderer, controls, geometry, cube;
        let resultObject, initialBox;

        let dims = { length: 1500, width: 600, thickness: 25 };
        const isNum = (v) => Number.isFinite(parseFloat(v));

        const materials = Array.from(
          { length: 6 },
          () =>
            new THREE.MeshStandardMaterial({
              color: Math.random() * 0xffffff,
              transparent: true,
              depthWrite: true,
              polygonOffset: true,
              polygonOffsetFactor: 0.2,
              polygonOffsetUnits: 0.2,
              side: THREE.DoubleSide,
              premultipliedAlpha: true,
            })
        );

        let discs = [];
        let brushes = [];

        // Define face keys - this ensures consistency across the application
        const FACES = {
          RIGHT: "right",
          LEFT: "left",
          TOP: "top",
          BOTTOM: "bottom",
          FRONT: "front",
          BACK: "back",
        };

        // Define Bevel Cut Directions
        const DIRECTIONS = {
          INWARD: "inward",
          OUTWARD: "outward",
        };

        // Define Mitre Cut Locations
        const LOCATIONS = {
          TOPLEFTCORNER: "top-left",
          TOPRIGHTCORNER: "top-right",
          BOTTOMLEFTCORNER: "bottom-left",
          BOTTOMRIGHTCORNER: "bottom-right",
          FRONTLEFTCORNER: "front-left",
          FRONTRIGHTCORNER: "front-right",
          BACKLEFTCORNER: "back-left",
          BACKRIGHTCORNER: "back-right",
          TOPFRONTCORNER: "top-front",
          TOPBACKCORNER: "top-back",
          BOTTOMFRONTCORNER: "bottom-front",
          BOTTOMBACKCORNER: "bottom-back",
        };

        // Mapping between face keys and BoxGeometry indices
        const faceKeyToIndex = {
          [FACES.RIGHT]: 0, // +X
          [FACES.LEFT]: 1, // -X
          [FACES.TOP]: 2, // +Y
          [FACES.BOTTOM]: 3, // -Y
          [FACES.FRONT]: 4, // +Z
          [FACES.BACK]: 5, // -Z
        };

        // Mapping between BoxGeometry indices and face keys
        const faceIndexToKey = {
          0: FACES.RIGHT,
          1: FACES.LEFT,
          2: FACES.TOP,
          3: FACES.BOTTOM,
          4: FACES.FRONT,
          5: FACES.BACK,
        };

        // Initialize when DOM is ready
        function init() {
          // Setup scene
          scene = new THREE.Scene();

          // Get container and its dimensions
          const container = document.getElementById("scene-container");
          const w = container.clientWidth,
            h = container.clientHeight;

          let light = new THREE.HemisphereLight(0xffffff, 0xffffff, 1);
          scene.add(light);

          // Setup camera
          camera = new THREE.PerspectiveCamera(50, w / h, 0.1, 10000);
          camera.position.set(0, 0, 2000);

          // Setup renderer
          renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setClearColor(0x000000, 0);
          renderer.setPixelRatio(2);
          renderer.setSize(w, h);
          container.appendChild(renderer.domElement);

          // Setup controls
          controls = new OrbitControls(camera, renderer.domElement);
          controls.enableZoom = false;
          controls.enablePan = false;
          controls.enableDamping = true;
          controls.dampingFactor = 0.05;
          controls.target.set(0, 0, 0);
          controls.minDistance = 500;
          controls.maxDistance = 5000;
          camera.lookAt(0, 0, 0);
          controls.update();

          // Create initial box with placeholder materials
          createBox(materials);
          updateCSG();

          // Load textures and set up event listeners
          loadInitialTextures();
          setupEventListeners();

          // Start animation immediately (will render with placeholder materials until textures load)
          animate();
        }

        // Load initial textures
        function loadInitialTextures() {
          // Map faces to texture paths - ensures textures are applied to correct faces
          const texturePaths = {
            [FACES.RIGHT]: "/face1.jpg", // Right face (+X)
            [FACES.LEFT]: "/face1.jpg", // Left face (-X)
            [FACES.TOP]: "/face1.jpg", // Top face (+Y)
            [FACES.BOTTOM]: "/face1.jpg", // Bottom face (-Y)
            [FACES.FRONT]: "/face1.jpg", // Front face (+Z)
            [FACES.BACK]: "/face1.jpg", // Back face (-Z)
          };

          // Face labels in the same order as THREE.js BoxGeometry faces
          const faceLabels = [
            "Right",
            "Left",
            "Top",
            "Bottom",
            "Front",
            "Back",
          ];

          // Add initial labels with placeholder materials
          addLabelsToBox(faceLabels);
          updateCameraPosition(true);

          // Create a counter to track loaded textures
          let loadedCount = 0;
          const totalTextures = Object.keys(texturePaths).length;

          // Load each texture using updateFaceTexture
          Object.entries(texturePaths).forEach(([faceKey, path]) => {
            updateFaceTexture(faceKey, path, () => {
              loadedCount++;

              // When all textures are loaded, make sure everything is updated
              if (loadedCount === totalTextures) {
                if (cube) cube.rotation.set(0, 0, 0);
                updateCameraPosition(true);
              }
            });
          });
        }

        // Create box with materials
        function createBox(materials) {
          if (cube) {
            scene.remove(cube);

            if (cube.userData.labelGroup) {
              scene.remove(cube.userData.labelGroup);
            }
            if (geometry) {
              geometry.dispose();
            }
          }

          // BoxGeometry creates faces in this order:
          // 0: positive-x (right)
          // 1: negative-x (left)
          // 2: positive-y (top)
          // 3: negative-y (bottom)
          // 4: positive-z (front)
          // 5: negative-z (back)
          geometry = new THREE.BoxGeometry(
            dims.width,
            dims.length,
            dims.thickness
          );

          // Verify materials array matches the number of faces
          const materialArray = Array.isArray(materials)
            ? materials.length >= 6
              ? materials
              : Array(6).fill(
                  materials[0] ||
                    new THREE.MeshStandardMaterial({
                      color: 0xcccccc,
                      side: THREE.DoubleSide,
                    })
                )
            : Array(6).fill(
                materials ||
                  new THREE.MeshStandardMaterial({
                    color: 0xcccccc,
                    side: THREE.DoubleSide,
                  })
              );

          cube = new threeBvhCsg.Brush(geometry, materialArray);
          cube.position.set(0, 0, 0);
          cube.rotation.set(0, 0, 0);
          cube.userData.initialRotationApplied = true;
          cube.updateWorldMatrix();

          // add object displaying the result
          resultObject = new THREE.Mesh(
            new THREE.BufferGeometry(),
            materialArray
          );
          resultObject.castShadow = true;
          resultObject.receiveShadow = true;
          scene.add(resultObject);

          initialBox = cube;

          scene.add(cube);

          updateCSG();

          return cube;
        }

        // Change model size
        function changeModelSize(
          newLength,
          newWidth,
          newThickness,
          updateLabels = true
        ) {
          newLength = isNum(newLength) ? newLength : dims.length;
          newWidth = isNum(newWidth) ? newWidth : dims.width;
          newThickness = isNum(newThickness) ? newThickness : dims.thickness;

          dims = {
            length: parseFloat(newLength),
            width: newWidth,
            thickness: newThickness,
          };

          createBox(materials);

          if (updateLabels) {
            addLabelsToBox(["Right", "Left", "Top", "Bottom", "Front", "Back"]);
          }

          // Update csg meshes
          updateCSGMeshes("moulding");
          updateCSGMeshes("bevelCut");
          updateCSGMeshes("mitreCut");
          updateCSGMeshes("corner");

          updateCameraPosition(true);
          return cube;
        }

        // Update CSG meshes
        function updateCSGMeshes(target) {
          if (target === "moulding") {
            // Update mouldings
            discs
              .filter((d) => d.type === "moulding")
              .forEach((item) => {
                editMoulding(item.id, item.face, {
                  topDistance: item.topDistance,
                  shapeId: item.shapeId,
                  shapeWidth: item.shapeWidth,
                  shapeHeight: item.shapeHeight,
                });
              });
          } else if (target === "bevelCut") {
            // Update Bevel Cuts
            discs
              .filter((d) => d.type === "bevelCut")
              .forEach((item) => {
                editBevelCut(item.id, {
                  edge: item.edge,
                  direction: item.direction,
                  angle: item.angle,
                });
              });
          } else if (target === "mitreCut") {
            // Update Mitre Cuts
            discs
              .filter((d) => d.type === "mitreCut")
              .forEach((item) =>
                editMitreCut(item.id, {
                  location: item.location,
                  angle: item.angle,
                })
              );
          } else if (target === "corner") {
            // Updates Corners
            discs
              .filter((d) => d.type === "corner")
              .forEach((item) =>
                editCorner(item.id, {
                  location: item.face,
                  firstDimension: item.firstDimension,
                  secondDimension: item.secondDimension,
                  radius: item.radius,
                })
              );
          }
        }

        // Update face texture using string key
        function updateFaceTexture(faceKey, texturePath, callback) {
          // Validate face key
          if (!Object.values(FACES).includes(faceKey)) {
            console.error(
              `Invalid face key: "${faceKey}". Must be one of: ${Object.values(
                FACES
              ).join(", ")}`
            );
            return;
          }

          // Convert face key to index for THREE.js BoxGeometry
          const faceIndex = faceKeyToIndex[faceKey];

          // Get human-readable face name for logging
          const faceName = faceKey.charAt(0).toUpperCase() + faceKey.slice(1);

          const loader = new THREE.TextureLoader();
          loader.load(
            texturePath,
            (texture) => {
              texture.generateMipmaps = true;
              texture.minFilter = THREE.LinearMipmapLinearFilter;
              texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

              const newMaterial = new THREE.MeshStandardMaterial({
                map: texture,
              });
              materials[faceIndex] = newMaterial;

              if (resultObject && resultObject.material) {
                if (Array.isArray(resultObject.material)) {
                  resultObject.material[faceIndex] = newMaterial;
                  resultObject.material.needsUpdate = true;
                } else {
                  createBox(materials);
                  addLabelsToBox();
                }
              }

              renderer.render(scene, camera);

              if (callback && typeof callback === "function") {
                callback(newMaterial);
              }
            },
            undefined,
            (error) => {
              // Use a fallback color if texture fails to load
              materials[faceIndex] = new THREE.MeshStandardMaterial({
                color: Math.random() * 0xffffff,
              });

              if (resultObject && resultObject.material) {
                if (Array.isArray(resultObject.material)) {
                  resultObject.material[faceIndex] = materials[faceIndex];
                  resultObject.material.needsUpdate = true;
                }
              }

              // Update csg meshes
              updateCSGMeshes("moulding");
              updateCSGMeshes("bevelCut");
              updateCSGMeshes("mitreCut");
              updateCSGMeshes("corner");

              if (callback && typeof callback === "function") {
                callback(materials[faceIndex]);
              }
            }
          );
        }

        // Add labels to box - maps directly to BoxGeometry face indices
        function addLabelsToBox(
          labelTexts = ["Right", "Left", "Top", "Bottom", "Front", "Back"]
        ) {
          if (!cube) return;

          if (cube.userData.labelGroup) {
            scene.remove(cube.userData.labelGroup);
          }

          const labelGroup = new THREE.Group();
          cube.userData.labelGroup = labelGroup;
          scene.add(labelGroup);

          const labelOffset = 150;

          // This array MUST follow the same order as THREE.BoxGeometry faces
          // BoxGeometry creates faces in this order: +x, -x, +y, -y, +z, -z
          const labelPositions = [
            { faceKey: FACES.RIGHT, axis: "x", sign: 1, defaultText: "Right" }, // Right (+X) = index 0
            { faceKey: FACES.LEFT, axis: "x", sign: -1, defaultText: "Left" }, // Left (-X) = index 1
            { faceKey: FACES.TOP, axis: "y", sign: 1, defaultText: "Top" }, // Top (+Y) = index 2
            {
              faceKey: FACES.BOTTOM,
              axis: "y",
              sign: -1,
              defaultText: "Bottom",
            }, // Bottom (-Y) = index 3
            { faceKey: FACES.FRONT, axis: "z", sign: 1, defaultText: "Front" }, // Front (+Z) = index 4
            { faceKey: FACES.BACK, axis: "z", sign: -1, defaultText: "Back" }, // Back (-Z) = index 5
          ];

          labelPositions.forEach((item, index) => {
            if (index >= 6) return;

            // Override default text if provided
            const text =
              index < labelTexts.length ? labelTexts[index] : item.defaultText;

            // Create position and face point vectors
            const position = [0, 0, 0];
            const facePoint = [0, 0, 0];

            // Set the appropriate dimension based on axis
            const dimValue =
              item.axis === "x"
                ? dims.width / 2
                : item.axis === "y"
                ? dims.length / 2
                : dims.thickness / 2;

            // Determine position index based on axis (x=0, y=1, z=2)
            const posIndex = item.axis === "x" ? 0 : item.axis === "y" ? 1 : 2;

            position[posIndex] = dimValue * item.sign + labelOffset * item.sign;
            facePoint[posIndex] = dimValue * item.sign;

            createLabel(text, position, facePoint, labelGroup);
          });

          return labelGroup;
        }

        // Create label
        function createLabel(text, position, facePoint, parentGroup) {
          const canvas = document.createElement("canvas");
          const context = canvas.getContext("2d");
          canvas.width = 256;
          canvas.height = 256;
          context.clearRect(0, 0, canvas.width, canvas.height);
          context.font = "Bold 50px Arial";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.strokeStyle = "white";
          context.lineWidth = 1;
          context.strokeText(text, canvas.width / 2, canvas.height / 2);
          context.fillStyle = "black";
          context.fillText(text, canvas.width / 2, canvas.height / 2);

          const texture = new THREE.CanvasTexture(canvas);
          const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
          });

          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.position.set(...position);
          const maxDim = Math.max(dims.width, dims.length, dims.thickness);
          const scaleFactor = maxDim / 10;
          sprite.scale.set(scaleFactor, scaleFactor, 1);
          parentGroup.add(sprite);

          const lineMaterial = new THREE.LineDashedMaterial({
            color: 0x000000,
            linewidth: 1,
            opacity: 0.5,
            transparent: true,
            dashSize: 3,
            gapSize: 15,
          });

          const points = [
            new THREE.Vector3(...facePoint),
            new THREE.Vector3(...position),
          ];

          const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
          const line = new THREE.Line(lineGeometry, lineMaterial);
          line.computeLineDistances();
          parentGroup.add(line);

          return sprite;
        }

        // Update camera position
        function updateCameraPosition(forceUpdate = false) {
          if (!cube) return;

          // Calculate object size and optimal camera distance
          const calculateOptimalDistance = () => {
            const size = new THREE.Vector3();
            new THREE.Box3().setFromObject(cube).getSize(size);

            const container = document.getElementById("scene-container");
            const containerAspect =
              container.clientWidth / container.clientHeight;
            const halfFov = THREE.MathUtils.degToRad(camera.fov / 2);
            const halfFovTan = Math.tan(halfFov);

            // Calculate constraints for width, height, and diagonal
            const halfWidth = size.x / 2;
            const halfHeight = size.y / 2;
            const widthConstraint = halfWidth / (halfFovTan * containerAspect);
            const heightConstraint = halfHeight / halfFovTan;
            const diagonalSquared =
              halfWidth * halfWidth + halfHeight * halfHeight;
            const diagonalConstraint = Math.sqrt(diagonalSquared) / halfFovTan;

            return {
              optimalDistance: Math.max(
                widthConstraint,
                heightConstraint,
                diagonalConstraint
              ),
              size: size,
            };
          };

          const { optimalDistance, size } = calculateOptimalDistance();
          const finalDistance = optimalDistance + size.z / 2;

          // Update camera and controls
          camera.position.set(0, 0, finalDistance);
          camera.lookAt(0, 0, 0);

          const maxDim = Math.max(size.x, size.y, size.z);
          controls.minDistance = maxDim * 0.5;
          controls.maxDistance = finalDistance * 3;
          controls.target.set(0, 0, 0);
          controls.update();

          if (forceUpdate) {
            renderer.render(scene, camera);
          }
        }

        // Animation loop
        function animate() {
          requestAnimationFrame(animate);
          if (controls.enableDamping) controls.update();
          TWEEN.update();
          renderer.render(scene, camera);
        }

        // Set up event listeners
        function setupEventListeners() {
          // Window load event
          window.addEventListener("load", () => {
            if (cube) {
              cube.rotation.set(0, 0, 0);
              updateCameraPosition(true);
            }
          });
        }

        function updateCSG() {
          const clearSceneMeshes = () => {
            for (let i = scene.children.length - 1; i >= 0; i--) {
              const obj = scene.children[i];
              if (obj.isMesh) {
                obj.geometry.dispose();
                scene.remove(obj);
              }
            }
          };

          if (brushes.length > 0) {
            let finalBrush = brushes[0];

            clearSceneMeshes();
            scene.add(resultObject);

            for (let i = 1; i < brushes.length; i++) {
              const brush = brushes[i];
              if (checkBrushOverlap(brush, cube)) {
                finalBrush = csgEvaluator.evaluate(
                  finalBrush,
                  brush,
                  threeBvhCsg.ADDITION
                );
              }
            }

            csgEvaluator.evaluate(
              cube,
              finalBrush,
              threeBvhCsg.SUBTRACTION,
              resultObject
            );
          } else {
            clearSceneMeshes();
            scene.add(cube);
          }

          renderer.render(scene, camera);
        }

        // Function to check if a brush overlaps with the cube (implement accordingly based on the structure of your brush and cube objects)
        function checkBrushOverlap(brush, cube) {
          // Create bounding boxes for brush and cube
          const brushBox = new THREE.Box3().setFromObject(brush);
          const cubeBox = new THREE.Box3().setFromObject(cube);

          // Check if the bounding boxes intersect
          return brushBox.intersectsBox(cubeBox);
        }

        // Function to create a shape from an array of points
        function createShape(points) {
          const shape = new THREE.Shape();
          shape.moveTo(points[0][0], points[0][1]);
          for (let i = 1; i < points.length; i++) {
            shape.lineTo(points[i][0], points[i][1]);
          }
          shape.lineTo(points[0][0], points[0][1]); // Close the shape
          shape.closePath();
          return shape;
        }

        // Generate shape from points
        function generateShapePoints(shapeId, shapeWidth, shapeHeight) {
          let shape = [[]];
          const basicLength = 40;

          switch (shapeId) {
            case "shape16":
              shape = [
                [0, shapeWidth / 2],
                [0, basicLength / 2],
                [shapeHeight, basicLength / 2],
                [shapeHeight, -basicLength / 2],
                [0, -basicLength / 2],
                [0, -shapeWidth / 2],
                [-shapeHeight, -shapeWidth / 2],
                [-shapeHeight, shapeWidth / 2],
              ];
              break;

            case "shape17":
              shape = [
                [0, shapeWidth / 2],
                [-shapeHeight, shapeWidth / 2],
                [-shapeHeight, basicLength / 2],
                [10, basicLength / 2],
                [10, -basicLength / 2],
                [-shapeHeight, -basicLength / 2],
                [-shapeHeight, -shapeWidth / 2],
                [0, -shapeWidth / 2],
              ];
              break;

            default:
              break;
          }

          return createShape(shape);
        }

        // Add Cut Hole
        function addThickCircle(cutHoleId, options = {}) {
          const defaults = {
            face: FACES.FRONT,
            topMM: 0,
            leftMM: 0,
            radius: 20,
            zOffset: 0, // ensure default exists
          };

          const config = { ...defaults, ...options };
          const { face, topMM, leftMM, radius, zOffset } = config;
          const { length, width, thickness } = dims;

          // Create geometry and material
          const geometry = new THREE.CylinderGeometry(
            radius,
            radius,
            thickness + 0.1,
            32
          );
          const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
          const mesh = new threeBvhCsg.Brush(geometry, material);

          // Position and rotation
          const pos = [0, 0, 0];
          switch (face) {
            case FACES.FRONT:
              pos[0] = -width / 2 + leftMM;
              pos[1] = length / 2 - topMM;
              pos[2] = 0;
              mesh.rotation.x = Math.PI / 2;
              break;

            case FACES.BACK:
              pos[0] = width / 2 - leftMM;
              pos[1] = length / 2 - topMM;
              pos[2] = -thickness / 2 - zOffset;
              mesh.rotation.x = -Math.PI / 2;
              break;

            case FACES.RIGHT:
              pos[0] = width / 2 + zOffset;
              pos[1] = length / 2 - topMM;
              pos[2] = thickness / 2 - leftMM;
              mesh.rotation.z = Math.PI / 2;
              break;

            case FACES.LEFT:
              pos[0] = -width / 2 - zOffset;
              pos[1] = length / 2 - topMM;
              pos[2] = -thickness / 2 + leftMM;
              mesh.rotation.z = -Math.PI / 2;
              break;

            case FACES.TOP:
              pos[0] = -width / 2 + leftMM;
              pos[1] = length / 2 + zOffset;
              pos[2] = -thickness / 2 + topMM;
              break;

            case FACES.BOTTOM:
              pos[0] = -width / 2 + leftMM;
              pos[1] = -length / 2 - zOffset;
              pos[2] = thickness / 2 - topMM;
              mesh.rotation.x = Math.PI;
              break;
          }

          mesh.position.set(...pos);
          mesh.updateWorldMatrix();
          mesh.userData.id = cutHoleId;

          // Replace existing brush with same ID
          brushes = brushes.filter((b) => b.userData.id !== cutHoleId);
          brushes.push(mesh);

          updateCSG();

          // Replace existing disc metadata
          discs = discs.filter((d) => d.id !== cutHoleId);
          discs.push({ id: cutHoleId, mesh, face, topMM, leftMM });

          renderer.render(scene, camera);
        }

        // Edit Cut Hole
        function editThickCircle(cutHoleId, options = {}) {
          addThickCircle(cutHoleId, options); // Reuse the existing logic to "edit" by overwriting
        }

        // Delete Cut Hole
        function deleteThickCircle(cutHoleId) {
          discs = discs.filter((d) => d.id !== cutHoleId);
          brushes = brushes.filter((b) => b.userData.id !== cutHoleId);
          updateCSG();
        }

        // Add Moulding
        function addMoulding(mouldingId, face, options = {}) {
          const defaults = {
            mouldingId: "",
            face: "",
            topDistance: 0,
            shapeId: "",
            shapeWidth: 0,
            shapeHeight: 0,
          };

          const config = {
            ...defaults,
            ...options,
            mouldingId,
            face,
          };

          const randomNum = Math.random() * (0.00009 - 0.00001) + 0.00001;
          config.shapeWidth += randomNum;

          const { length, width, thickness } = dims;

          let mouldingLength = 0;
          let discMaterial;
          const position = [0, 0, 0];
          const rotation = [0, 0, 0];

          const baseZ =
            -config.topDistance + (thickness / 2 - config.shapeWidth / 2);

          switch (face) {
            case FACES.FRONT:
              position[0] = -width / 2 + config.leftMM;
              position[1] = length / 2 - config.topMM;
              position[2] = thickness / 2 + config.zOffset;
              rotation[0] = Math.PI / 2;
              discMaterial = materials[4];
              break;

            case FACES.BACK:
              position[0] = width / 2 - config.leftMM;
              position[1] = length / 2 - config.topMM;
              position[2] = -thickness / 2 - config.zOffset;
              rotation[0] = -Math.PI / 2;
              discMaterial = materials[5];
              break;

            case FACES.RIGHT:
              position[0] = width / 2;
              position[1] = length / 2;
              position[2] = baseZ;
              rotation[0] = Math.PI / 2;
              mouldingLength = length;
              discMaterial = materials[0];
              break;

            case FACES.LEFT:
              position[0] = -width / 2;
              position[1] = -length / 2;
              position[2] = baseZ;
              rotation[0] = -Math.PI / 2;
              rotation[2] = Math.PI;
              mouldingLength = length;
              discMaterial = materials[1];
              break;

            case FACES.TOP: // +Y
              const topLeftMitreCuts = discs.filter(
                (d) => d.type === "mitreCut" && d.location === "top-left"
              );
              const topRightMitreCuts = discs.filter(
                (d) => d.type === "mitreCut" && d.location === "top-right"
              );

              mouldingLength = width;
              discMaterial = materials[2];

              if (topLeftMitreCuts.length > 0) {
                mouldingLength =
                  (width / Math.cos(topLeftMitreCuts[0].angle)) * 1.2;

                position[0] = width / 2;
                position[1] = length / 2;
                position[2] =
                  -config.topDistance +
                  (dims.thickness / 2 - config.shapeWidth / 2);

                rotation[0] = Math.PI / 2;
                rotation[1] = -Math.PI / 2 + topLeftMitreCuts[0].angle;
                rotation[2] = Math.PI;
              } else if (topRightMitreCuts.length > 0) {
                mouldingLength =
                  (width / Math.cos(topRightMitreCuts[0].angle)) * 1.2;

                position[0] = -width / 2;
                position[1] = length / 2;
                position[2] =
                  -config.topDistance +
                  (dims.thickness / 2 - config.shapeWidth / 2);

                rotation[0] = Math.PI / 2;
                rotation[1] = Math.PI / 2 - topRightMitreCuts[0].angle;
              } else {
                position[0] = -width / 2;
                position[1] = length / 2;
                position[2] =
                  -config.topDistance +
                  (dims.thickness / 2 - config.shapeWidth / 2);

                rotation[1] = Math.PI / 2;
                rotation[2] = Math.PI / 2;
              }
              break;

            case FACES.BOTTOM:
              {
                const leftCut = discs.filter(
                  (d) => d.type === "mitreCut" && d.location === "bottom-left"
                )[0];
                const rightCut = discs.filter(
                  (d) => d.type === "mitreCut" && d.location === "bottom-right"
                )[0];

                position[1] = -length / 2;
                position[2] = baseZ;
                mouldingLength = width;
                discMaterial = materials[3];

                if (leftCut) {
                  mouldingLength = (width / Math.cos(leftCut.angle)) * 1.2;
                  position[0] = -width / 2;
                  rotation[0] = -Math.PI / 2;
                  rotation[1] = Math.PI / 2 - leftCut.angle;
                } else if (rightCut) {
                  mouldingLength = (width / Math.cos(rightCut.angle)) * 1.2;
                  position[0] = width / 2;
                  rotation[0] = Math.PI / 2;
                  rotation[1] = -Math.PI / 2 - rightCut.angle;
                } else {
                  position[0] = -width / 2;
                  rotation[1] = Math.PI / 2;
                  rotation[2] = -Math.PI / 2;
                }
              }
              break;
          }

          const extrudeSettings = {
            steps: 5,
            depth: mouldingLength,
            bevelEnabled: false,
            curveSegments: 200,
          };

          const shape = generateShapePoints(
            config.shapeId,
            config.shapeWidth,
            config.shapeHeight
          );
          const discGeometry = new THREE.ExtrudeGeometry(
            shape,
            extrudeSettings
          );
          const discMesh = new threeBvhCsg.Brush(discGeometry, discMaterial);
          discMesh.userData.id = mouldingId;

          discMesh.position.set(...position);
          discMesh.rotation.set(...rotation);
          discMesh.updateWorldMatrix();

          // Update discs list
          discs = discs.filter((d) => d.id !== mouldingId);
          discs.push({
            id: mouldingId,
            type: "moulding",
            mesh: discMesh,
            face: config.face,
            topDistance: config.topDistance,
            shapeId: config.shapeId,
            shapeWidth: config.shapeWidth,
            shapeHeight: config.shapeHeight,
          });

          // Update brushes
          brushes = brushes.filter((item) => item.userData.id !== mouldingId);

          if (config.shapeWidth > 0 && config.shapeHeight > 0) {
            if (Math.abs(discMesh.position.z) < thickness / 2) {
              brushes.push(discMesh);
            }
            updateCSG();
          }
        }

        // Edit Moulding
        function editMoulding(mouldingId, face, options = {}) {
          addMoulding(mouldingId, face, options); // Reuse existing logic to overwrite
        }

        // Delete Moulding
        function deleteMoulding(mouldingId) {
          discs = discs.filter((d) => d.id !== mouldingId);
          brushes = brushes.filter((b) => b.userData.id !== mouldingId);
          updateCSG();
        }

        // Add bevel Cut
        function addBevelCut(bevelCutId, options = {}) {
          // Set default values and merge with options
          const config = {
            edge: "",
            direction: "",
            angle: 0,
            ...options,
            bevelCutId, // Ensure bevelCutId from parameter is used
          };

          // Get dimensions of initial box
          const { length, width, thickness: boxThickness } = dims;

          // Initialize position and dimension objects
          let discMaterial = new THREE.MeshStandardMaterial({});
          const bevelCutDims = { x: 0, y: 0, z: 0 };
          const bevelCutPos = { x: 0, y: 0, z: 0 };
          const firstGroupPos = { x: 0, y: 0, z: 0 };
          const firstGroupRot = { x: 0, y: 0, z: 0 };
          const secondGroupPos = { x: 0, y: 0, z: 0 };
          const thirdGroupPos = { x: 0, y: 0, z: 0 };
          const thirdGroupRot = { x: 0, y: 0, z: 0 };

          // Configure dimensions and positions based on edge and direction
          switch (config.edge) {
            case FACES.RIGHT: // +X
              discMaterial = materials[0].clone();
              bevelCutDims.x = boxThickness * 2;
              bevelCutDims.y = length;
              bevelCutDims.z = boxThickness * 2;
              firstGroupPos.x = width / 2;

              if (config.direction === DIRECTIONS.INWARD) {
                bevelCutPos.x = bevelCutDims.x / 2;
                bevelCutPos.z = -bevelCutDims.z / 2;
                firstGroupPos.z = boxThickness / 2;
                firstGroupRot.y = config.angle;
              } else if (config.direction === DIRECTIONS.OUTWARD) {
                bevelCutPos.x = bevelCutDims.x / 2;
                bevelCutPos.z = bevelCutDims.z / 2;
                firstGroupPos.z = -boxThickness / 2;
                firstGroupRot.y = -config.angle;
              }
              break;

            case FACES.LEFT: // -X
              discMaterial = materials[1].clone();
              bevelCutDims.x = boxThickness * 2;
              bevelCutDims.y = length;
              bevelCutDims.z = boxThickness * 2;
              firstGroupPos.x = -width / 2;

              if (config.direction === DIRECTIONS.INWARD) {
                bevelCutPos.x = -bevelCutDims.x / 2;
                bevelCutPos.z = -bevelCutDims.z / 2;
                firstGroupPos.z = boxThickness / 2;
                firstGroupRot.y = -config.angle;
              } else if (config.direction === DIRECTIONS.OUTWARD) {
                bevelCutPos.x = -bevelCutDims.x / 2;
                bevelCutPos.z = bevelCutDims.z / 2;
                firstGroupPos.z = -boxThickness / 2;
                firstGroupRot.y = config.angle;
              }
              break;

            case FACES.TOP: // +Y
              discMaterial = materials[2].clone();
              bevelCutDims.x = width * 4;
              bevelCutDims.y = boxThickness * 2;
              bevelCutDims.z = boxThickness * 4;
              firstGroupPos.y = length / 2;
              thirdGroupPos.y = length / 2;

              if (config.direction === DIRECTIONS.INWARD) {
                firstGroupPos.z = boxThickness / 2;
                bevelCutPos.y = bevelCutDims.y / 2;
                bevelCutPos.z = -bevelCutDims.z / 2;
                firstGroupRot.x = -config.angle;
                thirdGroupPos.z = boxThickness / 2;

                const sinAngle = Math.sin(config.angle);
                const cosAngle = Math.cos(config.angle);
                secondGroupPos.y = -(
                  (bevelCutDims.z / 2) * sinAngle +
                  (-bevelCutDims.y / 2) * cosAngle
                );
                secondGroupPos.z = -(
                  (bevelCutDims.z / 2) * cosAngle -
                  (-bevelCutDims.y / 2) * sinAngle
                );
              } else if (config.direction === DIRECTIONS.OUTWARD) {
                firstGroupPos.z = -boxThickness / 2;
                bevelCutPos.y = bevelCutDims.y / 2;
                bevelCutPos.z = bevelCutDims.z / 2;
                firstGroupRot.x = config.angle;
                thirdGroupPos.z = -boxThickness / 2;

                const sinAngle = Math.sin(Math.PI * 2 - config.angle);
                const cosAngle = Math.cos(Math.PI * 2 - config.angle);
                secondGroupPos.y = -(
                  (-bevelCutDims.z / 2) * sinAngle +
                  (-bevelCutDims.y / 2) * cosAngle
                );
                secondGroupPos.z = -(
                  (-bevelCutDims.z / 2) * cosAngle -
                  (-bevelCutDims.y / 2) * sinAngle
                );
              }

              // Handle mitre cuts
              const topLeftMitreCuts = discs
                .filter((d) => d.type === "mitreCut")
                .filter((item) => item.location === "top-left");
              const topRightMitreCuts = discs
                .filter((d) => d.type === "mitreCut")
                .filter((item) => item.location === "top-right");

              if (topLeftMitreCuts.length > 0) {
                thirdGroupRot.z = topLeftMitreCuts[0].angle;
                thirdGroupPos.x = width / 2;
              } else if (topRightMitreCuts.length > 0) {
                thirdGroupRot.z = -topRightMitreCuts[0].angle;
                thirdGroupPos.x = -width / 2;
              }
              break;

            case FACES.BOTTOM: // -Y
              discMaterial = materials[3].clone();
              bevelCutDims.x = width * 4;
              bevelCutDims.y = boxThickness * 2;
              bevelCutDims.z = boxThickness * 2;
              firstGroupPos.y = -length / 2;
              thirdGroupPos.y = -length / 2;

              if (config.direction === DIRECTIONS.INWARD) {
                firstGroupPos.z = boxThickness / 2;
                bevelCutPos.y = -bevelCutDims.y / 2;
                bevelCutPos.z = -bevelCutDims.z / 2;
                firstGroupRot.x = config.angle - Math.PI / 2;
                thirdGroupPos.z = boxThickness / 2;

                const sinAngle = Math.sin(Math.PI * 2 - config.angle);
                const cosAngle = Math.cos(Math.PI * 2 - config.angle);
                secondGroupPos.y = -(
                  (bevelCutDims.z / 2) * sinAngle +
                  (bevelCutDims.y / 2) * cosAngle
                );
                secondGroupPos.z = -(
                  (bevelCutDims.z / 2) * cosAngle -
                  (bevelCutDims.y / 2) * sinAngle
                );
              } else if (config.direction === DIRECTIONS.OUTWARD) {
                firstGroupPos.z = boxThickness / 2;
                bevelCutPos.y = -bevelCutDims.y / 2;
                bevelCutPos.z = -bevelCutDims.z / 2;
                firstGroupRot.x = Math.PI / 2 - config.angle;
                thirdGroupPos.z = -boxThickness / 2;

                const sinAngle = Math.sin(config.angle);
                const cosAngle = Math.cos(config.angle);
                secondGroupPos.y = -(
                  (-bevelCutDims.z / 2) * sinAngle +
                  (bevelCutDims.y / 2) * cosAngle
                );
                secondGroupPos.z = -(
                  (-bevelCutDims.z / 2) * cosAngle -
                  (bevelCutDims.y / 2) * sinAngle
                );
              }

              // Handle mitre cuts
              const bottomLeftMitreCuts = discs
                .filter((d) => d.type === "mitreCut")
                .filter((item) => item.location === "bottom-left");
              const bottomRightMitreCuts = discs
                .filter((d) => d.type === "mitreCut")
                .filter((item) => item.location === "bottom-right");

              if (bottomLeftMitreCuts.length > 0) {
                thirdGroupRot.z = bottomLeftMitreCuts[0].angle;
                thirdGroupPos.x = -width / 2;
              } else if (bottomRightMitreCuts.length > 0) {
                thirdGroupRot.z = -bottomRightMitreCuts[0].angle;
                thirdGroupPos.x = width / 2;
              }
              break;
          }

          // Exit early if required parameters are missing or invalid
          if (!config.direction || !config.edge || config.angle === 0) {
            return; // No need to proceed without valid configuration
          }

          // Create the bevel cut mesh
          const discGeometry = new THREE.BoxGeometry(
            bevelCutDims.x,
            bevelCutDims.y,
            bevelCutDims.z
          );
          const discMesh = new threeBvhCsg.Brush(discGeometry, discMaterial);
          discMesh.position.set(bevelCutPos.x, bevelCutPos.y, bevelCutPos.z);

          // Create first group and add disc mesh
          const firstGroup = new THREE.Group();
          firstGroup.add(discMesh);
          firstGroup.position.set(
            firstGroupPos.x,
            firstGroupPos.y,
            firstGroupPos.z
          );
          firstGroup.rotation.set(
            firstGroupRot.x,
            firstGroupRot.y,
            firstGroupRot.z
          );

          // Create second group with transformed geometry
          const secondGroup = new THREE.Group();
          firstGroup.traverse((child) => {
            if (child.isMesh && child.geometry) {
              child.updateWorldMatrix(true, false);

              const geometry = child.geometry.clone();
              geometry.applyMatrix4(child.matrixWorld);

              const mesh = new threeBvhCsg.Brush(
                geometry,
                child.material.clone()
              );
              mesh.userData.id = bevelCutId;

              secondGroup.add(mesh);
            }
          });

          // Position the second group correctly if needed
          if (
            (config.edge === "top" || config.edge === "bottom") &&
            config.angle > 0
          ) {
            const box = new THREE.Box3().setFromObject(secondGroup);
            const center = box.getCenter(new THREE.Vector3());
            secondGroup.position.set(
              secondGroupPos.x - center.x,
              secondGroupPos.y - center.y,
              secondGroupPos.z - center.z
            );
          }

          // Create third group with further transformations
          const thirdGroup = new THREE.Group();
          secondGroup.traverse((child) => {
            if (child.isMesh && child.geometry) {
              child.updateWorldMatrix(true, false);

              const geometry = child.geometry.clone();
              geometry.applyMatrix4(child.matrixWorld);

              const mesh = new threeBvhCsg.Brush(
                geometry,
                child.material.clone()
              );
              mesh.userData.id = bevelCutId;

              thirdGroup.add(mesh);
            }
          });
          thirdGroup.position.set(
            thirdGroupPos.x,
            thirdGroupPos.y,
            thirdGroupPos.z
          );
          thirdGroup.rotation.set(
            thirdGroupRot.x,
            thirdGroupRot.y,
            thirdGroupRot.z
          );

          // Add to discs array
          discs = discs.filter((item) => item.id !== bevelCutId);
          discs.push({
            id: bevelCutId,
            type: "bevelCut",
            mesh: discMesh,
            edge: config.edge,
            direction: config.direction,
            angle: config.angle,
          });

          // Update brushes data
          brushes = brushes.filter((item) => item.userData.id !== bevelCutId);

          // Add new brushes from the third group
          thirdGroup.traverse((child) => {
            if (child.isMesh && child.geometry) {
              child.updateWorldMatrix(true, false);
              const geometry = child.geometry.clone();
              geometry.applyMatrix4(child.matrixWorld);

              const mesh = new threeBvhCsg.Brush(
                geometry,
                child.material.clone()
              );
              mesh.userData.id = bevelCutId;

              brushes.push(mesh);
              scene.add(mesh);
            }
          });

          // Update CSG
          updateCSG();
        }

        // Edit Bevel Cut
        function editBevelCut(bevelCutId, options = {}) {
          addBevelCut(bevelCutId, { ...options });
        }

        // Remove Bevel Cut
        function deleteBevelCut(bevelCutId) {
          discs = discs.filter((item) => item.id !== bevelCutId);
          brushes = brushes.filter((item) => item.userData.id !== bevelCutId);
          updateCSG();
        }

        // Add Mitre Cut
        function addMitreCut(mitreCutId, options = {}) {
          const defaults = {
            mitreCutId: "",
            location: "",
            angle: 0,
          };

          const config = {
            ...defaults,
            ...options,
            mitreCutId: mitreCutId,
          };

          const { length, width, thickness: boxThickness } = dims;

          // Get moulding length
          let mitreCutPos = { x: 0, y: 0, z: 0 };
          let mitreCutRot = { x: 0, y: 0, z: 0 };

          switch (config.location) {
            case LOCATIONS.TOPLEFTCORNER:
              mitreCutPos.y = length / 2 - 0.01;
              mitreCutRot.z = config.angle;
              break;

            case LOCATIONS.TOPRIGHTCORNER:
              mitreCutPos.y = length / 2 - 0.01;
              mitreCutRot.z = -config.angle;

              break;

            case LOCATIONS.BOTTOMLEFTCORNER:
              mitreCutPos.y = -length / 2 + 0.01;
              mitreCutRot.z = config.angle;

              break;

            case LOCATIONS.BOTTOMRIGHTCORNER:
              mitreCutPos.y = -length / 2 + 0.01;
              mitreCutRot.z = -config.angle;

              break;
          }

          const discGeometry = new THREE.BoxGeometry(
            (width * 2) / Math.cos(config.angle),
            width * Math.cos(Math.PI / 2 - config.angle),
            boxThickness
          );

          // Create a material
          let discMaterial = new THREE.MeshStandardMaterial();

          switch (config.location) {
            case LOCATIONS.TOPLEFTCORNER: // +Y
              discMaterial = materials[2].clone();
              break;

            case LOCATIONS.TOPRIGHTCORNER: // +Y
              discMaterial = materials[2].clone();
              break;

            case LOCATIONS.BOTTOMLEFTCORNER: // -Y
              discMaterial = materials[3].clone();
              break;

            case LOCATIONS.BOTTOMRIGHTCORNER: // -Y
              discMaterial = materials[3].clone();
              break;
          }

          const discMesh = new threeBvhCsg.Brush(discGeometry, discMaterial);

          discMesh.userData.id = mitreCutId;
          discMesh.rotation.set(mitreCutRot.x, mitreCutRot.y, mitreCutRot.z);
          discMesh.position.set(mitreCutPos.x, mitreCutPos.y, mitreCutPos.z);

          discMesh.updateWorldMatrix();

          discs = discs.filter((d) => d.id !== mitreCutId);
          brushes = brushes.filter((b) => b.userData.id !== mitreCutId);

          if (config.angle !== 0 && config.direction !== "") {
            discs.push({
              id: mitreCutId,
              type: "mitreCut",
              mesh: discMesh,
              location: config.location,
              angle: config.angle,
            });

            brushes = brushes.filter((b) => b.userData.id !== mitreCutId);

            brushes.push(discMesh);

            updateCSG();
          }
        }

        // Edit Mitre Cut
        function editMitreCut(mitreCutId, options = {}) {
          addMitreCut(mitreCutId, { ...options });
          updateCSGMeshes("moulding");
          updateCSGMeshes("bevelCut");
          updateCSGMeshes("corner");
        }

        // Remove Mitre Cut
        function deleteMitreCut(mitreCutId) {
          discs = discs.filter((d) => d.id !== mitreCutId);
          brushes = brushes.filter((b) => b.userData.id !== mitreCutId);

          updateCSGMeshes("moulding");
          updateCSGMeshes("bevelCut");
          updateCSGMeshes("mitreCut");
          updateCSGMeshes("corner");

          updateCSG();
        }

        // Add Corner
        function addCorner(cornerId, options = {}) {
          const defaults = {
            cornerId: "",
            location: "",
            radius: 0,
            firstDimension: 0,
            secondDimension: 0,
            delta: 20,
          };

          const config = {
            ...defaults,
            ...options,
            cornerId: cornerId,
          };

          const { length, width, thickness: boxThickness } = dims;

          let cornerDepth = 0;

          let cornerPos = { x: 0, y: 0, z: 0 };
          let cornerRot = { x: 0, y: 0, z: 0 };

          switch (config.location) {
            case LOCATIONS.TOPLEFTCORNER:
              cornerDepth = boxThickness + 10;

              cornerRot.z = Math.PI / 2;
              cornerPos.x = -width / 2 - config.delta;
              cornerPos.y = length / 2 + config.delta;
              cornerPos.z = -cornerDepth / 2;
              break;

            case LOCATIONS.TOPRIGHTCORNER:
              cornerDepth = boxThickness + 10;

              cornerPos.x = width / 2 + config.delta;
              cornerPos.y = length / 2 + config.delta;
              cornerPos.z = -cornerDepth / 2;
              break;

            case LOCATIONS.BOTTOMLEFTCORNER:
              cornerDepth = boxThickness + 10;

              cornerRot.z = Math.PI;
              cornerPos.x = -width / 2 - config.delta;
              cornerPos.y = -length / 2 - config.delta;
              cornerPos.z = -cornerDepth / 2;
              break;

            case LOCATIONS.BOTTOMRIGHTCORNER:
              cornerDepth = boxThickness + 10;

              cornerRot.z = -Math.PI / 2;
              cornerPos.x = width / 2 + config.delta;
              cornerPos.y = -length / 2 - config.delta;
              cornerPos.z = -cornerDepth / 2;
              break;

            case LOCATIONS.FRONTLEFTCORNER:
              cornerDepth = length + config.delta;

              cornerPos.x = -width / 2 - config.delta;
              cornerPos.y = cornerDepth / 2;
              cornerPos.z = boxThickness / 2 + config.delta;
              cornerRot.x = Math.PI / 2;
              cornerRot.z = Math.PI / 2;
              break;

            case LOCATIONS.FRONTRIGHTCORNER:
              cornerDepth = length + config.delta;

              cornerPos.x = width / 2 + config.delta;
              cornerPos.y = cornerDepth / 2;
              cornerPos.z = boxThickness / 2 + config.delta;
              cornerRot.x = Math.PI / 2;
              break;

            case LOCATIONS.BACKLEFTCORNER:
              cornerDepth = length + config.delta;

              cornerPos.x = -width / 2 - config.delta;
              cornerPos.y = cornerDepth / 2;
              cornerPos.z = -boxThickness / 2 - config.delta;
              cornerRot.x = Math.PI / 2;
              cornerRot.z = Math.PI;
              break;

            case LOCATIONS.BACKRIGHTCORNER:
              cornerDepth = length + config.delta;

              cornerPos.x = width / 2 + config.delta;
              cornerPos.y = cornerDepth / 2;
              cornerPos.z = -boxThickness / 2 - config.delta;
              cornerRot.x = Math.PI / 2;
              cornerRot.z = -Math.PI / 2;
              break;

            case LOCATIONS.TOPFRONTCORNER:
              cornerDepth = width + config.delta;

              cornerPos.x = -cornerDepth / 2;
              cornerPos.y = length / 2 + config.delta;
              cornerPos.z = boxThickness / 2 + config.delta;
              cornerRot.x = Math.PI / 2;
              cornerRot.y = Math.PI / 2;
              break;

            case LOCATIONS.TOPBACKCORNER:
              cornerDepth = width + config.delta;

              cornerPos.x = -cornerDepth / 2;
              cornerPos.y = length / 2 + config.delta;
              cornerPos.z = -boxThickness / 2 - config.delta;

              cornerRot.y = Math.PI / 2;
              break;

            case LOCATIONS.BOTTOMFRONTCORNER:
              cornerDepth = width + config.delta;

              cornerPos.x = -cornerDepth / 2;
              cornerPos.y = -length / 2 - config.delta;
              cornerPos.z = boxThickness / 2 + config.delta;

              cornerRot.y = Math.PI / 2;
              cornerRot.z = -Math.PI;
              break;

            case LOCATIONS.BOTTOMBACKCORNER:
              cornerDepth = width + config.delta;

              cornerPos.x = -cornerDepth / 2;
              cornerPos.y = -length / 2 - config.delta;
              cornerPos.z = -boxThickness / 2 - config.delta;

              cornerRot.y = Math.PI / 2;
              cornerRot.z = -Math.PI / 2;
              break;
          }

          const extrudeSettings = {
            steps: 5,
            depth: cornerDepth,
            bevelEnabled: false,
            curveSegments: 200,
          };

          const shape = new THREE.Shape();
          shape.moveTo(0, 0);
          shape.lineTo(0, -config.delta - config.secondDimension);
          shape.lineTo(-config.delta, -config.delta - config.secondDimension);
          shape.quadraticCurveTo(
            -config.delta - (config.firstDimension * config.radius) / 100,
            -config.delta - (config.secondDimension * config.radius) / 100,
            -config.delta - config.firstDimension,
            -config.delta
          );
          // shape.lineTo(-config.delta - config.firstDimension, -config.delta);
          shape.lineTo(-config.delta - config.firstDimension, 0);
          shape.lineTo(0, 0);

          const discGeometry = new THREE.ExtrudeGeometry(
            shape,
            extrudeSettings
          );

          const discMaterial = new THREE.MeshStandardMaterial({
            color: 0xff00ff,
          });

          const discMesh = new threeBvhCsg.Brush(discGeometry, discMaterial);
          discMesh.userData.id = config.cornerId;
          discMesh.position.set(cornerPos.x, cornerPos.y, cornerPos.z);
          discMesh.rotation.set(cornerRot.x, cornerRot.y, cornerRot.z);
          discMesh.updateWorldMatrix();

          discs = discs.filter((d) => d.id !== config.cornerId);
          discs.push({
            id: config.cornerId,
            type: "corner",
            face: config.location,
            radius: config.radius,
            firstDimension: config.firstDimension,
            secondDimension: config.secondDimension,
          });

          brushes = brushes.filter(
            (item) => item.userData.id !== config.cornerId
          );

          if (config.firstDimension > 0 && config.secondDimension > 0) {
            brushes.push(discMesh);
            updateCSG();
          }
        }

        function editCorner(cornerId, options = {}) {
          addCorner(cornerId, { ...options });
        }

        function deleteCorner(cornerId) {
          discs = discs.filter((d) => d.id !== cornerId);
          brushes = brushes.filter((b) => b.userData.id !== cornerId);

          updateCSG();
        }

        // Return public API
        return {
          init: init,
          changeModelSize: changeModelSize,
          updateFaceTexture: updateFaceTexture,
          addLabelsToBox: addLabelsToBox,
          addThickCircle: addThickCircle,
          editThickCircle: editThickCircle,
          deleteThickCircle: deleteThickCircle,
          updateCameraPosition: updateCameraPosition,
          getScene: () => scene,
          getCamera: () => camera,
          getControls: () => controls,
          getCube: () => cube,
          getDimensions: () => ({ ...dims }),
          getMaterials: () => [...materials],
          FACES: FACES, // Export face
          addMoulding: addMoulding,
          editMoulding: editMoulding,
          deleteMoulding: deleteMoulding,
          addBevelCut: addBevelCut,
          editBevelCut: editBevelCut,
          deleteBevelCut: deleteBevelCut,
          DIRECTIONS: DIRECTIONS,
          addMitreCut: addMitreCut,
          editMitreCut: editMitreCut,
          deleteMitreCut: deleteMitreCut,
          addCorner: addCorner,
          editCorner: editCorner,
          deleteCorner: deleteCorner,
        };
      })();

      // Export BoxModel to the global scope so it can be accessed from the console
      globalThis.BoxModel = BoxModel;

      // Example usage from console:
      // BoxModel.updateFaceTexture(BoxModel.FACES.TOP, "/path/to/texture.jpg");

      // Initialize the model when the document is ready
      document.addEventListener("DOMContentLoaded", BoxModel.init);

      document.getElementById("model-width").addEventListener("change", (e) => {
        BoxModel.changeModelSize(
          BoxModel.getDimensions().length,
          parseFloat(e.target.value),
          BoxModel.getDimensions().thickness
        );
      });
      document
        .getElementById("model-length")
        .addEventListener("change", (e) => {
          BoxModel.changeModelSize(
            parseFloat(e.target.value),
            BoxModel.getDimensions().width,
            BoxModel.getDimensions().thickness
          );
        });
      document
        .getElementById("model-thickness")
        .addEventListener("change", (e) => {
          BoxModel.changeModelSize(
            BoxModel.getDimensions().length,
            BoxModel.getDimensions().width,
            parseFloat(e.target.value)
          );
        });

      const mouldingsContainer = document.getElementById("mouldings-container");

      function addMoulding() {
        // Generate moulding Id
        const mouldingId =
          Date.now().toString() + Math.random().toString(36).substr(2, 9);

        // Create a new moulding item
        const newItem = document.createElement("div");
        newItem.classList.add("moulding-item");
        newItem.dataset.mouldingId = mouldingId; // Unique ID

        newItem.innerHTML = `
          <div class="input-group mb-2">
              <select class="form-select moulding-face">
                  <option value="left">Left</option>
                  <option value="right">Right</option>
                  <option value="top">Top</option>
                  <option value="bottom">Bottom</option>
              </select>
              <input type="number" placeholder="Distance from Top" class="form-control moulding-distance"  />
              <select class="form-select moulding-shape" >
                  <option value="">None</option>
                  <option value="shape16">Shape 16</option>
                  <option value="shape17">Shape 17</option>
              </select>
              <input type="number" placeholder="Shape Width" class="form-control shape-width" />
              <input type="number" placeholder="Shape Height" class="form-control shape-height"  />
              <button onclick="BoxModel.deleteMoulding(this.closest('.moulding-item').dataset.mouldingId)" type="button" class="btn btn-danger remove-moulding" id="delete-moulding-btn">
                  Delete
              </button>
          </div>
        `;
        // Append new item to container
        mouldingsContainer.appendChild(newItem);

        BoxModel.addMoulding(mouldingId, BoxModel.FACES.LEFT, {});
      }

      document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("add-moulding-btn").onclick = () =>
          addMoulding();

        mouldingsContainer.addEventListener("click", (e) => {
          if (e.target.closest(".remove-moulding")) {
            const item = e.target.closest(".moulding-item");
            const mouldingId = item.dataset.mouldingId;

            BoxModel.deleteMoulding(mouldingId);

            item.remove();
          }
        });

        mouldingsContainer.addEventListener("change", (e) => {
          if (
            [
              "moulding-face",
              "moulding-distance",
              "moulding-shape",
              "shape-width",
              "shape-height",
            ].some((cls) => e.target.classList.contains(cls))
          ) {
            const item = e.target.closest(".moulding-item");

            const mouldingId = item.dataset.mouldingId;
            const mouldingFace = item.querySelector(".moulding-face")?.value;
            const mouldingDistance =
              item.querySelector(".moulding-distance")?.value;
            const mouldingShape = item.querySelector(".moulding-shape")?.value;
            const shapeWidth = item.querySelector(".shape-width")?.value;
            const shapeHeight = item.querySelector(".shape-height")?.value;

            BoxModel.editMoulding(mouldingId, mouldingFace, {
              topDistance: parseFloat(mouldingDistance),
              shapeId: mouldingShape,
              shapeWidth: parseFloat(shapeWidth),
              shapeHeight: parseFloat(shapeHeight),
            });
          }
        });
      });

      const cutHolesContainer = document.getElementById("cutouts-container");

      function addCutHole() {
        // Generate moulding Id
        const cutHoleId =
          Date.now().toString() + Math.random().toString(36).substr(2, 9);

        // Create a new moulding item
        const newItem = document.createElement("div");
        newItem.classList.add("cutout-item");
        newItem.dataset.cutHoleId = cutHoleId; // Unique ID

        newItem.innerHTML = `
          <div class="input-group mb-2">
            <input type="number" placeholder="Top" value="100" class="cutout-top form-control">
            <input type="number" placeholder="Left" value="100" class="cutout-left form-control">
            <select class="form-select cutout-diameter">
              <option value="40">40mm</option>
              <option value="60">60mm</option>
            </select>
            <button type="button" class="btn btn-danger remove-cutout">Delete</button>
          </div>
        `;
        // Append new item to container
        cutHolesContainer.appendChild(newItem);

        const defaultValues = {
          topMM: 100,
          leftMM: 100,
          radius: 20,
        };

        BoxModel.addThickCircle(cutHoleId, defaultValues);
      }

      document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("add-cutout-btn").onclick = () => addCutHole();

        cutHolesContainer.addEventListener("click", (e) => {
          if (e.target.closest(".remove-cutout")) {
            const item = e.target.closest(".cutout-item");
            const cutHoleId = item.dataset.cutHoleId;

            BoxModel.deleteThickCircle(cutHoleId);

            item.remove();
          }
        });

        cutHolesContainer.addEventListener("change", (e) => {
          if (
            ["cutout-top", "cutout-left", "cutout-diameter"].some((cls) =>
              e.target.classList.contains(cls)
            )
          ) {
            const item = e.target.closest(".cutout-item");

            const cutHoleId = item.dataset.cutHoleId;
            const cutHoleTop = item.querySelector(".cutout-top")?.value;
            const cutHoleLeft = item.querySelector(".cutout-left")?.value;
            const cutHoleDiameter =
              item.querySelector(".cutout-diameter")?.value;

            BoxModel.editThickCircle(cutHoleId, {
              topMM: parseFloat(cutHoleTop),
              leftMM: parseFloat(cutHoleLeft),
              radius: parseFloat(cutHoleDiameter) / 2,
            });
          }
        });
      });

      const bevelcutsContainer = document.getElementById("bevels-container");

      function addBevelcut() {
        // Generate moulding Id
        const bevelCutId =
          Date.now().toString() + Math.random().toString(36).substr(2, 9);

        // Create a new moulding item
        const newItem = document.createElement("div");
        newItem.classList.add("bevel-cut-item");
        newItem.dataset.bevelCutId = bevelCutId; // Unique ID

        newItem.innerHTML = `
          <div class="input-group mb-2">
              <select class="form-select cut-location" id="bevel-location">
                  <option value="">Edge</option>
                  <option value="top">Top Edge</option>
                  <option value="left">Left Edge</option>
                  <option value="right">Right Edge</option>
                  <option value="bottom">Bottom Edge</option>
              </select>
              <select class="form-select cut-direction" id="bevel-direction">
                  <option value="">Direction</option>
                  <option value="inward">Inward</option>
                  <option value="outward">Outward</option>
              </select>
              <select class="form-select cut-angle" id="bevel-angle">
                  <option value="">Angle</option>
                  <option value="15">15°</option>
                  <option value="22.5">22.5°</option>
                  <option value="30">30°</option>
                  <option value="45">45°</option>
              </select>
              <button type="button" class="btn btn-danger remove-bevel-cut" id="delete-moulding-btn">
                  Delete
              </button>
          </div>
      `;

        // Append new item to container
        bevelcutsContainer.appendChild(newItem);

        const defaultValues = {
          edge: "",
          direction: "",
          angle: 0,
        };

        BoxModel.addBevelCut(bevelCutId, defaultValues);
      }

      document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("add-bevelcut-btn").onclick = () =>
          addBevelcut();

        bevelcutsContainer.addEventListener("click", (e) => {
          if (e.target.closest(".remove-bevel-cut")) {
            const item = e.target.closest(".bevel-cut-item");
            const bevelCutId = item.dataset.bevelCutId;

            BoxModel.deleteBevelCut(bevelCutId);

            item.remove();
          }
        });

        bevelcutsContainer.addEventListener("change", (e) => {
          if (
            ["cut-location", "cut-direction", "cut-angle"].some((cls) =>
              e.target.classList.contains(cls)
            )
          ) {
            const item = e.target.closest(".bevel-cut-item");

            const bevelCutId = item.dataset.bevelCutId;
            const bevelLocation = item.querySelector(".cut-location")?.value;
            const bevelDirection = item.querySelector(".cut-direction")?.value;
            const bevelAngle = item.querySelector(".cut-angle")?.value;

            BoxModel.editBevelCut(bevelCutId, {
              edge: bevelLocation,
              direction: bevelDirection,
              angle: (bevelAngle * Math.PI) / 180,
            });
          }
        });
      });

      const mitreCutContainer = document.getElementById("mitre-cut-container");

      function addMitreCut() {
        // Generate moulding Id
        const mitreCutId =
          Date.now().toString() + Math.random().toString(36).substr(2, 9);

        // Create a new moulding item
        const newItem = document.createElement("div");
        newItem.classList.add("mitre-cut-item");
        newItem.dataset.mitreCutId = mitreCutId; // Unique ID

        newItem.innerHTML = `
          <div class="input-group mb-2">
              <select class="form-select cut-location" id="mitre-location">
                  <option value="">Corner</option>
                  <option value="top-left">Top Left Corner</option>
                  <option value="top-right">Top Right Corner</option>
                  <option value="bottom-left">Bottom Left Corner</option>
                  <option value="bottom-right">Bottom Right Corner</option>
              </select>
              <select class="form-select cut-angle">
                  <option value="">Angle</option>
                  <option value="15">15°</option>
                  <option value="22.5">22.5°</option>
                  <option value="30">30°</option>
                  <option value="45">45°</option>
              </select>
              <button type="button" class="btn btn-danger remove-mitre-cut" id="delete-moulding-btn">
                  Delete
              </button>
          </div>
      `;

        // Append new item to container
        mitreCutContainer.appendChild(newItem);

        const defaultValues = {
          location: "",
          angle: 0,
        };

        BoxModel.addMitreCut(mitreCutId, defaultValues);
      }

      document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("add-mitrecut-btn").onclick = () =>
          addMitreCut();

        mitreCutContainer.addEventListener("click", (e) => {
          if (e.target.closest(".remove-mitre-cut")) {
            const item = e.target.closest(".mitre-cut-item");
            const mitreCutId = item.dataset.mitreCutId;

            BoxModel.deleteMitreCut(mitreCutId);

            item.remove();
          }
        });

        mitreCutContainer.addEventListener("change", (e) => {
          if (
            ["cut-location", "cut-angle"].some((cls) =>
              e.target.classList.contains(cls)
            )
          ) {
            const item = e.target.closest(".mitre-cut-item");

            const mitreCutId = item.dataset.mitreCutId;
            const mitreLocation = item.querySelector(".cut-location")?.value;
            const mitreAngle = item.querySelector(".cut-angle")?.value;

            BoxModel.editMitreCut(mitreCutId, {
              location: mitreLocation,
              angle: (mitreAngle * Math.PI) / 180,
            });
          }
        });
      });

      const cornerContainer = document.getElementById("corners-container");

      function addCorner() {
        // Generate moulding Id
        const cornerId =
          Date.now().toString() + Math.random().toString(36).substr(2, 9);

        // Create a new moulding item
        const newItem = document.createElement("div");
        newItem.classList.add("corner-item");
        newItem.dataset.cornerId = cornerId; // Unique ID

        newItem.innerHTML = `
            <div class="input-group mb-2">
              <select class="form-select corner-location" id="corner-location">
                <option value="">Corner</option>
                <option value="top-left">Top Left Corner</option>
                <option value="top-right">Top Right Corner</option>
                <option value="bottom-left">Bottom Left Corner</option>
                <option value="bottom-right">Bottom Right Corner</option>

                <option value="front-left">Front Left Corner</option>
                <option value="front-right">Front Right Corner</option>
                <option value="back-left">Back Left Corner</option>
                <option value="back-right">Back Right Corner</option>

                <option value="top-front">Top Front Corner</option>
                <option value="top-back">Top Back Corner</option>
                <option value="bottom-front">Bottom Front Corner</option>
                <option value="bottom-back">Bottom Back Corner</option>
              </select>
              <input
                type="number"
                placeholder="First Dimension"
                class="corner-first-dimension form-control"
              />
              <input
                type="number"
                placeholder="Second Dimension"
                class="corner-second-dimension form-control"
              />
              <input
                type="number"
                placeholder="Radius"
                min="0"
                max="100"
                class="corner-radius form-control"
              />
              <button
                type="button"
                class="btn btn-danger remove-corner"
                id="delete-corner-btn"
              >
                Delete
              </button>
            </div>
      `;

        // Append new item to container
        cornerContainer.appendChild(newItem);

        const defaultValues = {
          location: "top-left",
          radius: 0,
          firstDimension: 0,
          secondDimension: 0,
        };

        BoxModel.addCorner(cornerId, defaultValues);
      }

      document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("add-corner-btn").onclick = () => addCorner();

        cornerContainer.addEventListener("click", (e) => {
          if (e.target.closest(".remove-corner")) {
            const item = e.target.closest(".corner-item");
            const cornerId = item.dataset.cornerId;

            BoxModel.deleteCorner(cornerId);

            item.remove();
          }
        });

        cornerContainer.addEventListener("change", (e) => {
          if (
            [
              "corner-location",
              "corner-first-dimension",
              "corner-second-dimension",
              "corner-radius",
            ].some((cls) => e.target.classList.contains(cls))
          ) {
            const item = e.target.closest(".corner-item");

            const cornerId = item.dataset.cornerId;
            const cornerLocation =
              item.querySelector(".corner-location")?.value;
            const cornerFirstDimension = item.querySelector(
              ".corner-first-dimension"
            )?.value;
            const cornerSecondDimension = item.querySelector(
              ".corner-second-dimension"
            )?.value;
            const cornerRadius = item.querySelector(".corner-radius")?.value;

            BoxModel.editCorner(cornerId, {
              location: cornerLocation,
              radius: parseFloat(cornerRadius),
              firstDimension: parseFloat(cornerFirstDimension),
              secondDimension: parseFloat(cornerSecondDimension),
            });
          }
        });
      });
    </script>
  </body>
</html>
