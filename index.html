<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <style>
      body {
        margin: 0;
      }

      #scene-container {
        height: 100vh !important;
      }

      #container {
        display: flex;
      }

      #container #layout-container {
        padding: 40px;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.148.0/examples/jsm/"
        }
      }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
  </head>
  <body>
    <div id="container">
      <div
        id="scene-container"
        style="width: 50% !important; height: 100%"
      ></div>
      <div id="layout-container" style="width: 50% !important; height: 100%">
        <div class="section-box">
          <h2>Dimensions</h2>
          <div class="input-group">
            <input
              type="number"
              id="model-width"
              placeholder="Width"
              value="600"
              min="300"
              max="1524"
              class="form-control"
            />

            <input
              type="number"
              id="model-length"
              placeholder="Length"
              value="1500"
              min="300"
              max="2743"
              class="form-control"
            />

            <select id="model-thickness" class="form-select">
              <option value="25.4">25.4mm</option>
              <option value="15.875">15.875mm</option>
              <option value="100">100mm</option>
              <option value="200">200mm</option>
              <option value="300">300mm</option>
            </select>
          </div>
        </div>
        <div class="section-box">
          <h2>Moulding</h2>
          <div id="mouldings-container"></div>
          <div class="mt-2 text-end">
            <button
              type="button"
              class="btn btn-sm btn-primary"
              id="add-moulding-btn"
            >
              Add Moulding
            </button>
          </div>
        </div>
        <div class="section-box">
          <h2>Edge Banding</h2>
          <div class="input-group">
            <select
              class="form-select"
              id="top-select"
              onchange="BoxModel.updateFaceTexture('top',this.value);"
            >
              <option value="/pb.jpg">None</option>
              <option value="/walnut.jpg">Walnut</option>
            </select>

            <select
              class="form-select"
              id="right-select"
              onchange="BoxModel.updateFaceTexture('right',this.value);"
            >
              <option value="/pb.jpg">None</option>
              <option value="/walnut.jpg">Walnut</option>
            </select>
            <select
              class="form-select"
              id="bottom-select"
              onchange="BoxModel.updateFaceTexture('bottom',this.value);"
            >
              <option value="/pb.jpg">None</option>
              <option value="/walnut.jpg">Walnut</option>
            </select>
            <select
              class="form-select"
              id="left-select"
              onchange="BoxModel.updateFaceTexture('left',this.value);"
            >
              <option value="/pb.jpg">None</option>
              <option value="/walnut.jpg">Walnut</option>
            </select>
          </div>
        </div>
        <div class="section-box">
          <h2>Cutout Holes</h2>
          <div id="cutouts-container"></div>
          <div class="mt-2 text-end">
            <button
              type="button"
              class="btn btn-sm btn-primary"
              id="add-cutout-btn"
            >
              Add Cutout
            </button>
          </div>
          <input
            type="hidden"
            name="cutout_holes_data"
            id="cutout-holes-data"
          />
        </div>
        <div class="section-box">
          <h2>Bevel Cut</h2>
          <div id="bevels-container"></div>
          <div class="mt-2 text-end">
            <button
              type="button"
              class="btn btn-sm btn-primary"
              id="add-bevelcut-btn"
            >
              Add Cutout
            </button>
          </div>
        </div>
        <div class="section-box">
          <h2>Mitre Cut</h2>
          <div id="mitre-cut-container"></div>
          <div class="mt-2 text-end">
            <button
              type="button"
              class="btn btn-sm btn-primary"
              id="add-mitrecut-btn"
            >
              Add Cutout
            </button>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import * as threeBvhCsg from "https://cdn.jsdelivr.net/npm/three-bvh-csg@0.0.16/+esm";

      let csgEvaluator = new threeBvhCsg.Evaluator();
      csgEvaluator.useGroup = true;

      // Create a global model module using an immediately invoked function expression (IIFE)
      const BoxModel = (function () {
        // Private variables
        let scene, camera, renderer, controls, geometry, cube;
        let dims = { length: 1500, width: 600, thickness: 25 };
        const isNum = (v) => !isNaN(parseFloat(v)) && isFinite(v);
        let materials = Array(6)
          .fill()
          .map(
            () =>
              new THREE.MeshStandardMaterial({
                color: Math.random() * 0xffffff,
              })
          );
        let discs = [];
        const materialMap = new Map();
        let resultObject;
        let initialBox;
        let brushes = [];
        let mouldingData = [];
        let holesData = [];
        let bevelCutsData = [];
        let mitreCutsData = [];

        // ...existing code...

        // Function to create a shape from an array of points
        function createShape(points) {
          const shape = new THREE.Shape();
          shape.moveTo(points[0][0], points[0][1]);
          for (let i = 1; i < points.length; i++) {
            shape.lineTo(points[i][0], points[i][1]);
          }
          shape.lineTo(points[0][0], points[0][1]); // Close the shape
          shape.closePath();
          return shape;
        }

        // Define points for shapes
        const points16 = [
          [0, 3],
          [0, 20],
          [10, 20],
          [10, -20],
          [0, -20],
          [0, -3],
          [-10, -3],
          [-10, 3],
        ];
        const points17 = [
          [0, 3],
          [-9.5, 3],
          [-9.5, 20],
          [10, 20],
          [10, -20],
          [-9.5, -20],
          [-9.5, -3],
          [0, -3],
        ];

        // Create shapes using the function
        const shape16 = createShape(points16);
        const shape17 = createShape(points17);

        const shapeMap = { shape16: shape16, shape17: shape17 };
        const shapeDims = {
          shape0: { width: 6 },
          shape16: { width: 6 },
          shape17: { width: 6 },
        };

        function getShapeById(shapeId) {
          return shapeMap[shapeId];
        }

        function getShapeDimsById(shapeId) {
          return shapeDims[shapeId];
        }

        // Initialize when DOM is ready
        function init() {
          // Setup scene
          scene = new THREE.Scene();

          // Get container and its dimensions
          const container = document.getElementById("scene-container");
          const w = container.clientWidth,
            h = container.clientHeight;

          let light = new THREE.HemisphereLight(0xffffff, 0xffffff, 1);
          scene.add(light);

          // Setup camera
          camera = new THREE.PerspectiveCamera(50, w / h, 0.1, 10000);
          camera.position.set(0, 0, 2000);

          // Setup renderer
          renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setClearColor(0x000000, 0);
          renderer.setPixelRatio(2);
          renderer.setSize(w, h);
          container.appendChild(renderer.domElement);

          // Setup controls
          controls = new OrbitControls(camera, renderer.domElement);
          controls.enableZoom = false;
          controls.enablePan = false;
          controls.enableDamping = true;
          controls.dampingFactor = 0.05;
          controls.target.set(0, 0, 0);
          controls.minDistance = 500;
          controls.maxDistance = 5000;
          camera.lookAt(0, 0, 0);
          controls.update();

          // Create initial box with placeholder materials
          createBox(materials);
          updateCSG();

          // Load textures and set up event listeners
          loadInitialTextures();
          setupEventListeners();

          // Start animation immediately (will render with placeholder materials until textures load)
          animate();
        }

        // Define face keys - this ensures consistency across the application
        const FACES = {
          RIGHT: "right",
          LEFT: "left",
          TOP: "top",
          BOTTOM: "bottom",
          FRONT: "front",
          BACK: "back",
        };

        // Define Bevel Cut Directions
        const DIRECTIONS = {
          INWARD: "inward",
          OUTWARD: "outward",
        };

        // Define Mitre Cut Locations
        const LOCATIONS = {
          TOPLEFTCORNER: "top-left",
          TOPRIGHTCORNER: "top-right",
          BOTTOMLEFTCORNER: "bottom-left",
          BOTTOMRIGHTCORNER: "bottom-right",
        };

        // Mapping between face keys and BoxGeometry indices
        const faceKeyToIndex = {
          [FACES.RIGHT]: 0, // +X
          [FACES.LEFT]: 1, // -X
          [FACES.TOP]: 2, // +Y
          [FACES.BOTTOM]: 3, // -Y
          [FACES.FRONT]: 4, // +Z
          [FACES.BACK]: 5, // -Z
        };

        // Mapping between BoxGeometry indices and face keys
        const faceIndexToKey = {
          0: FACES.RIGHT,
          1: FACES.LEFT,
          2: FACES.TOP,
          3: FACES.BOTTOM,
          4: FACES.FRONT,
          5: FACES.BACK,
        };

        // Load initial textures
        function loadInitialTextures() {
          // Map faces to texture paths - ensures textures are applied to correct faces
          const texturePaths = {
            [FACES.RIGHT]: "/face1.jpg", // Right face (+X)
            [FACES.LEFT]: "/face1.jpg", // Left face (-X)
            [FACES.TOP]: "/face1.jpg", // Top face (+Y)
            [FACES.BOTTOM]: "/face1.jpg", // Bottom face (-Y)
            [FACES.FRONT]: "/face1.jpg", // Front face (+Z)
            [FACES.BACK]: "/face1.jpg", // Back face (-Z)
          };

          // Face labels in the same order as THREE.js BoxGeometry faces
          const faceLabels = [
            "Right",
            "Left",
            "Top",
            "Bottom",
            "Front",
            "Back",
          ];

          // Add initial labels with placeholder materials
          addLabelsToBox(faceLabels);
          updateCameraPosition(true);

          // Create a counter to track loaded textures
          let loadedCount = 0;
          const totalTextures = Object.keys(texturePaths).length;

          // Load each texture using updateFaceTexture
          Object.entries(texturePaths).forEach(([faceKey, path]) => {
            updateFaceTexture(faceKey, path, () => {
              loadedCount++;

              // When all textures are loaded, make sure everything is updated
              if (loadedCount === totalTextures) {
                if (cube) cube.rotation.set(0, 0, 0);
                updateCameraPosition(true);
              }
            });
          });
        }

        // Then replace the addThickCircle function with this implementation:
        function addThickCircle(radius, thickness, options = {}) {
          // Default options for positioning
          const defaults = {
            face: FACES.FRONT, // Default face to place the circle on
            topMM: 0, // Distance from top edge in millimeters
            leftMM: 0, // Distance from left edge in millimeters
            zOffset: 0, // Offset from the face surface
            color: Math.random() * 0xffffff,
            opacity: 0.7,
          };

          // Merge provided options with defaults
          const config = { ...defaults, ...options };

          // Create a cylinder geometry with equal top and bottom radius
          const discGeometry = new THREE.CylinderGeometry(
            radius, // radiusTop
            radius, // radiusBottom
            dims.thickness + 0.1, // height (thickness)
            32, // radialSegments
            1, // heightSegments
            false // openEnded
          );

          // Create a material
          const discMaterial = new THREE.MeshStandardMaterial({
            color: 0xff0000,
          });

          // Create the mesh
          const discMesh = new threeBvhCsg.Brush(discGeometry, discMaterial);

          // Calculate position based on face, millimeter coordinates, and dimensions
          const position = [0, 0, 0];

          // Get current dimensions
          const { length, width, thickness: boxThickness } = dims;

          // Calculate actual position based on face and millimeter measurements
          switch (config.face) {
            case FACES.FRONT: // +Z
              // For front face: origin at top-left, X increases right, Y increases down
              position[0] = -width / 2 + config.leftMM;
              position[1] = length / 2 - config.topMM;
              position[2] = 0;
              discMesh.rotation.x = Math.PI / 2;
              break;

            case FACES.BACK: // -Z
              // For back face: origin at top-right (when viewed from behind), X increases left, Y increases down
              position[0] = width / 2 - config.leftMM;
              position[1] = length / 2 - config.topMM;
              position[2] = -boxThickness / 2 - config.zOffset;
              discMesh.rotation.x = -Math.PI / 2;
              break;

            case FACES.RIGHT: // +X
              // For right face: origin at top-front, X increases toward back, Y increases down
              position[0] = width / 2 + config.zOffset;
              position[1] = length / 2 - config.topMM;
              position[2] = boxThickness / 2 - config.leftMM;
              discMesh.rotation.z = Math.PI / 2;
              break;

            case FACES.LEFT: // -X
              // For left face: origin at top-back, X increases toward front, Y increases down
              position[0] = -width / 2 - config.zOffset;
              position[1] = length / 2 - config.topMM;
              position[2] = -boxThickness / 2 + config.leftMM;
              discMesh.rotation.z = -Math.PI / 2;
              break;

            case FACES.TOP: // +Y
              // For top face: origin at back-left, X increases right, Y increases forward
              position[0] = -width / 2 + config.leftMM;
              position[1] = length / 2 + config.zOffset;
              position[2] = -boxThickness / 2 + config.topMM;
              // Default rotation works for top face
              break;

            case FACES.BOTTOM: // -Y
              // For bottom face: origin at front-left, X increases right, Y increases backward
              position[0] = -width / 2 + config.leftMM;
              position[1] = -length / 2 - config.zOffset;
              position[2] = boxThickness / 2 - config.topMM;
              discMesh.rotation.x = Math.PI;
              break;
          }

          // Set position
          discMesh.position.set(...position);
          discMesh.updateWorldMatrix();

          // Add to scene
          // scene.add(discMesh);
          brushes.push(discMesh);

          updateCSG();

          // Store the disc for later reference
          const discId =
            Date.now().toString() + Math.random().toString(36).substr(2, 9);
          discs.push({
            id: discId,
            mesh: discMesh,
            face: config.face,
            topMM: config.topMM,
            leftMM: config.leftMM,
          });

          // Render the scene
          renderer.render(scene, camera);

          // Return the disc's ID so it can be removed later
          return discId;
        }

        function editThickCircle(discId, options = {}) {
          // Find the disc by ID
          const discIndex = discs.findIndex((disc) => disc.id === discId);

          if (discIndex === -1) {
            console.error(`Disc with ID ${discId} not found.`);
            return false;
          }

          const disc = discs[discIndex];
          const discMesh = disc.mesh;

          // Update properties based on provided options
          if (options.radius !== undefined) {
            // Update the geometry with a new radius
            const oldGeometry = discMesh.geometry;
            const newGeometry = new THREE.CylinderGeometry(
              options.radius, // radiusTop
              options.radius, // radiusBottom
              oldGeometry.parameters.height, // keep the same thickness
              32, // radialSegments
              1, // heightSegments
              false // openEnded
            );

            discMesh.geometry.dispose();
            discMesh.geometry = newGeometry;
          }

          if (options.thickness !== undefined) {
            // Update the geometry with a new thickness
            const oldGeometry = discMesh.geometry;
            const newGeometry = new THREE.CylinderGeometry(
              oldGeometry.parameters.radiusTop, // keep the same radius
              oldGeometry.parameters.radiusBottom,
              options.thickness, // new thickness
              32, // radialSegments
              1, // heightSegments
              false // openEnded
            );

            discMesh.geometry.dispose();
            discMesh.geometry = newGeometry;
          }

          // Update material properties
          if (options.color !== undefined) {
            discMesh.material.color.set(options.color);
          }

          if (options.opacity !== undefined) {
            discMesh.material.opacity = options.opacity;
            // Ensure transparency is enabled if opacity < 1
            discMesh.material.transparent = options.opacity < 1;
          }

          // Update position if topMM or leftMM changed
          const positionChanged =
            options.topMM !== undefined || options.leftMM !== undefined;
          if (positionChanged) {
            // Get current dimensions
            const { length, width, thickness: boxThickness } = dims;

            // Get the face from the disc object or use the provided face
            const face = options.face || disc.face;

            // Update the disc's stored values
            if (options.topMM !== undefined) {
              disc.topMM = options.topMM;
            }

            if (options.leftMM !== undefined) {
              disc.leftMM = options.leftMM;
            }

            if (options.face !== undefined) {
              disc.face = options.face;

              // Reset rotation based on the new face
              discMesh.rotation.set(0, 0, 0);

              switch (options.face) {
                case FACES.FRONT:
                  discMesh.rotation.x = Math.PI / 2;
                  break;
                case FACES.BACK:
                  discMesh.rotation.x = -Math.PI / 2;
                  break;
                case FACES.RIGHT:
                  discMesh.rotation.z = Math.PI / 2;
                  break;
                case FACES.LEFT:
                  discMesh.rotation.z = -Math.PI / 2;
                  break;
                case FACES.TOP:
                  // Default rotation works for top face
                  break;
                case FACES.BOTTOM:
                  discMesh.rotation.x = Math.PI;
                  break;
              }
            }

            // Calculate new position
            const position = [0, 0, 0];
            const zOffset =
              options.zOffset !== undefined
                ? options.zOffset
                : discMesh.position.y - length / 2 > 0
                ? discMesh.position.y - length / 2
                : 0;

            switch (disc.face) {
              case FACES.FRONT:
                position[0] = -width / 2 + disc.leftMM;
                position[1] = length / 2 - disc.topMM;
                position[2] = boxThickness / 2 + zOffset;
                break;
              case FACES.BACK:
                position[0] = width / 2 - disc.leftMM;
                position[1] = length / 2 - disc.topMM;
                position[2] = -boxThickness / 2 - zOffset;
                break;
              case FACES.RIGHT:
                position[0] = width / 2 + zOffset;
                position[1] = length / 2 - disc.topMM;
                position[2] = boxThickness / 2 - disc.leftMM;
                break;
              case FACES.LEFT:
                position[0] = -width / 2 - zOffset;
                position[1] = length / 2 - disc.topMM;
                position[2] = -boxThickness / 2 + disc.leftMM;
                break;
              case FACES.TOP:
                position[0] = -width / 2 + disc.leftMM;
                position[1] = length / 2 + zOffset;
                position[2] = -boxThickness / 2 + disc.topMM;
                break;
              case FACES.BOTTOM:
                position[0] = -width / 2 + disc.leftMM;
                position[1] = -length / 2 - zOffset;
                position[2] = boxThickness / 2 - disc.topMM;
                break;
            }

            // Update position
            discMesh.position.set(...position);
          }

          // Render the scene
          renderer.render(scene, camera);

          return true;
        }

        function deleteThickCircle(discId) {
          const updatedItems = discs.filter((item) => item.id === discId)[0];
          const updateBrushes = brushes.filter(
            (item) => item !== updatedItems.mesh
          );
          brushes = updateBrushes;

          updateCSG();

          return true;
        }

        // Create box with materials
        function createBox(materials) {
          if (cube) {
            scene.remove(cube);

            if (cube.userData.labelGroup) {
              scene.remove(cube.userData.labelGroup);
            }
            if (geometry) {
              geometry.dispose();
            }
          }

          // BoxGeometry creates faces in this order:
          // 0: positive-x (right)
          // 1: negative-x (left)
          // 2: positive-y (top)
          // 3: negative-y (bottom)
          // 4: positive-z (front)
          // 5: negative-z (back)
          geometry = new THREE.BoxGeometry(
            dims.width,
            dims.length,
            dims.thickness
          );

          // Verify materials array matches the number of faces
          const materialArray = Array.isArray(materials)
            ? materials.length >= 6
              ? materials
              : Array(6).fill(
                  materials[0] ||
                    new THREE.MeshStandardMaterial({
                      color: 0xcccccc,
                      side: THREE.DoubleSide,
                    })
                )
            : Array(6).fill(
                materials ||
                  new THREE.MeshStandardMaterial({
                    color: 0xcccccc,
                    side: THREE.DoubleSide,
                  })
              );

          cube = new threeBvhCsg.Brush(geometry, materialArray);
          cube.position.set(0, 0, 0);
          cube.rotation.set(0, 0, 0);
          cube.userData.initialRotationApplied = true;
          cube.updateWorldMatrix();

          // add object displaying the result
          resultObject = new THREE.Mesh(
            new THREE.BufferGeometry(),
            materialArray
          );
          resultObject.castShadow = true;
          resultObject.receiveShadow = true;
          scene.add(resultObject);

          initialBox = cube;

          scene.add(cube);

          updateCSG();

          return cube;
        }

        // Change model size
        function changeModelSize(
          newLength,
          newWidth,
          newThickness,
          updateLabels = true
        ) {
          newLength = isNum(newLength) ? newLength : dims.length;
          newWidth = isNum(newWidth) ? newWidth : dims.width;
          newThickness = isNum(newThickness) ? newThickness : dims.thickness;

          dims = {
            length: parseFloat(newLength),
            width: newWidth,
            thickness: newThickness,
          };

          createBox(materials);

          if (updateLabels) {
            addLabelsToBox(["Right", "Left", "Top", "Bottom", "Front", "Back"]);
          }

          // Update csg meshes
          updateCSGMeshes("moulding");
          updateCSGMeshes("bevelCut");
          updateCSGMeshes("mitreCut");

          updateCameraPosition(true);
          return cube;
        }

        // Update CSG meshes
        function updateCSGMeshes(target) {
          if (target === "moulding") {
            // Update mouldings
            mouldingData.forEach((item) => {
              editMoulding("face", item.face, item.id);
              editMoulding("topDistance", item.topDistance, item.id);
              editMoulding("shapeId", item.shapeId, item.id);
            });
          }
          if (target === "bevelCut") {
            // Update Bevel Cuts
            bevelCutsData.forEach((item) => {
              editBevelCut(item.id, {
                edge: item.edge,
                direction: item.direction,
                angle: item.angle,
              });
            });
          }
          if (target === "mitreCut") {
            // Update Mitre Cuts
            mitreCutsData.forEach((item) =>
              editMitreCut(item.id, {
                location: item.location,
                angle: item.angle,
              })
            );
          }
        }

        // Update face texture using string key
        function updateFaceTexture(faceKey, texturePath, callback) {
          // Validate face key
          if (!Object.values(FACES).includes(faceKey)) {
            console.error(
              `Invalid face key: "${faceKey}". Must be one of: ${Object.values(
                FACES
              ).join(", ")}`
            );
            return;
          }

          // Convert face key to index for THREE.js BoxGeometry
          const faceIndex = faceKeyToIndex[faceKey];

          // Get human-readable face name for logging
          const faceName = faceKey.charAt(0).toUpperCase() + faceKey.slice(1);

          const loader = new THREE.TextureLoader();
          loader.load(
            texturePath,
            (texture) => {
              texture.generateMipmaps = true;
              texture.minFilter = THREE.LinearMipmapLinearFilter;
              texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

              const newMaterial = new THREE.MeshStandardMaterial({
                map: texture,
              });
              materials[faceIndex] = newMaterial;

              if (resultObject && resultObject.material) {
                if (Array.isArray(resultObject.material)) {
                  resultObject.material[faceIndex] = newMaterial;
                  resultObject.material.needsUpdate = true;
                } else {
                  createBox(materials);
                  addLabelsToBox();
                }
              }

              // Update csg meshes
              updateCSGMeshes("moulding");
              updateCSGMeshes("bevelCut");
              updateCSGMeshes("mitreCut");

              renderer.render(scene, camera);

              if (callback && typeof callback === "function") {
                callback(newMaterial);
              }
            },
            undefined,
            (error) => {
              // Use a fallback color if texture fails to load
              materials[faceIndex] = new THREE.MeshStandardMaterial({
                color: Math.random() * 0xffffff,
              });

              if (resultObject && resultObject.material) {
                if (Array.isArray(resultObject.material)) {
                  resultObject.material[faceIndex] = materials[faceIndex];
                  resultObject.material.needsUpdate = true;
                }
              }

              // Update csg meshes
              updateCSGMeshes("moulding");
              updateCSGMeshes("bevelCut");
              updateCSGMeshes("mitreCut");

              if (callback && typeof callback === "function") {
                callback(materials[faceIndex]);
              }
            }
          );
        }

        // Add labels to box - maps directly to BoxGeometry face indices
        function addLabelsToBox(
          labelTexts = ["Right", "Left", "Top", "Bottom", "Front", "Back"]
        ) {
          if (!cube) return;

          if (cube.userData.labelGroup) {
            scene.remove(cube.userData.labelGroup);
          }

          const labelGroup = new THREE.Group();
          cube.userData.labelGroup = labelGroup;
          scene.add(labelGroup);

          const labelOffset = 150;

          // This array MUST follow the same order as THREE.BoxGeometry faces
          // BoxGeometry creates faces in this order: +x, -x, +y, -y, +z, -z
          const labelPositions = [
            { faceKey: FACES.RIGHT, axis: "x", sign: 1, defaultText: "Right" }, // Right (+X) = index 0
            { faceKey: FACES.LEFT, axis: "x", sign: -1, defaultText: "Left" }, // Left (-X) = index 1
            { faceKey: FACES.TOP, axis: "y", sign: 1, defaultText: "Top" }, // Top (+Y) = index 2
            {
              faceKey: FACES.BOTTOM,
              axis: "y",
              sign: -1,
              defaultText: "Bottom",
            }, // Bottom (-Y) = index 3
            { faceKey: FACES.FRONT, axis: "z", sign: 1, defaultText: "Front" }, // Front (+Z) = index 4
            { faceKey: FACES.BACK, axis: "z", sign: -1, defaultText: "Back" }, // Back (-Z) = index 5
          ];

          labelPositions.forEach((item, index) => {
            if (index >= 6) return;

            // Override default text if provided
            const text =
              index < labelTexts.length ? labelTexts[index] : item.defaultText;

            // Create position and face point vectors
            const position = [0, 0, 0];
            const facePoint = [0, 0, 0];

            // Set the appropriate dimension based on axis
            const dimValue =
              item.axis === "x"
                ? dims.width / 2
                : item.axis === "y"
                ? dims.length / 2
                : dims.thickness / 2;

            // Determine position index based on axis (x=0, y=1, z=2)
            const posIndex = item.axis === "x" ? 0 : item.axis === "y" ? 1 : 2;

            position[posIndex] = dimValue * item.sign + labelOffset * item.sign;
            facePoint[posIndex] = dimValue * item.sign;

            createLabel(text, position, facePoint, labelGroup);
          });

          return labelGroup;
        }

        // Create label
        function createLabel(text, position, facePoint, parentGroup) {
          const canvas = document.createElement("canvas");
          const context = canvas.getContext("2d");
          canvas.width = 256;
          canvas.height = 256;
          context.clearRect(0, 0, canvas.width, canvas.height);
          context.font = "Bold 50px Arial";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.strokeStyle = "white";
          context.lineWidth = 1;
          context.strokeText(text, canvas.width / 2, canvas.height / 2);
          context.fillStyle = "black";
          context.fillText(text, canvas.width / 2, canvas.height / 2);

          const texture = new THREE.CanvasTexture(canvas);
          const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
          });

          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.position.set(...position);
          const maxDim = Math.max(dims.width, dims.length, dims.thickness);
          const scaleFactor = maxDim / 10;
          sprite.scale.set(scaleFactor, scaleFactor, 1);
          parentGroup.add(sprite);

          const lineMaterial = new THREE.LineDashedMaterial({
            color: 0x000000,
            linewidth: 1,
            opacity: 0.5,
            transparent: true,
            dashSize: 3,
            gapSize: 15,
          });

          const points = [
            new THREE.Vector3(...facePoint),
            new THREE.Vector3(...position),
          ];

          const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
          const line = new THREE.Line(lineGeometry, lineMaterial);
          line.computeLineDistances();
          parentGroup.add(line);

          return sprite;
        }

        // Update camera position
        function updateCameraPosition(forceUpdate = false) {
          if (!cube) return;

          // Calculate object size and optimal camera distance
          const calculateOptimalDistance = () => {
            const size = new THREE.Vector3();
            new THREE.Box3().setFromObject(cube).getSize(size);

            const container = document.getElementById("scene-container");
            const containerAspect =
              container.clientWidth / container.clientHeight;
            const halfFov = THREE.MathUtils.degToRad(camera.fov / 2);
            const halfFovTan = Math.tan(halfFov);

            // Calculate constraints for width, height, and diagonal
            const halfWidth = size.x / 2;
            const halfHeight = size.y / 2;
            const widthConstraint = halfWidth / (halfFovTan * containerAspect);
            const heightConstraint = halfHeight / halfFovTan;
            const diagonalSquared =
              halfWidth * halfWidth + halfHeight * halfHeight;
            const diagonalConstraint = Math.sqrt(diagonalSquared) / halfFovTan;

            return {
              optimalDistance: Math.max(
                widthConstraint,
                heightConstraint,
                diagonalConstraint
              ),
              size: size,
            };
          };

          const { optimalDistance, size } = calculateOptimalDistance();
          const finalDistance = optimalDistance + size.z / 2;

          // Update camera and controls
          camera.position.set(0, 0, finalDistance);
          camera.lookAt(0, 0, 0);

          const maxDim = Math.max(size.x, size.y, size.z);
          controls.minDistance = maxDim * 0.5;
          controls.maxDistance = finalDistance * 3;
          controls.target.set(0, 0, 0);
          controls.update();

          if (forceUpdate) {
            renderer.render(scene, camera);
          }
        }

        // Animation loop
        function animate() {
          requestAnimationFrame(animate);
          if (controls.enableDamping) controls.update();
          TWEEN.update();
          renderer.render(scene, camera);
        }

        // Set up event listeners
        function setupEventListeners() {
          // Window load event
          window.addEventListener("load", () => {
            if (cube) {
              cube.rotation.set(0, 0, 0);
              updateCameraPosition(true);
            }
          });
        }

        function updateCSG() {
          if (brushes.length > 0) {
            let finalBrush = brushes[0];

            for (let i = scene.children.length - 1; i >= 0; i--) {
              let obj = scene.children[i];
              if (obj.isMesh) {
                obj.geometry.dispose(); // Dispose geometry
                scene.remove(obj); // Remove from scene
              }
            }
            scene.add(resultObject);

            for (let i = 1, l = brushes.length; i < l; i++) {
              const b = brushes[i];
              const isOverlapping = checkBrushOverlap(b, cube);

              if (isOverlapping) {
                finalBrush = csgEvaluator.evaluate(
                  finalBrush,
                  b,
                  threeBvhCsg.ADDITION
                );
              }
            }

            csgEvaluator.evaluate(
              cube,
              finalBrush,
              threeBvhCsg.SUBTRACTION,
              resultObject
            );
          } else {
            for (let i = scene.children.length - 1; i >= 0; i--) {
              let obj = scene.children[i];
              if (obj.isMesh) {
                obj.geometry.dispose(); // Dispose geometry
                scene.remove(obj); // Remove from scene
              }
            }

            scene.add(cube);
          }
          renderer.render(scene, camera);
        }

        // Function to check if a brush overlaps with the cube (implement accordingly based on the structure of your brush and cube objects)
        function checkBrushOverlap(brush, cube) {
          // Create bounding boxes for brush and cube
          const brushBox = new THREE.Box3().setFromObject(brush);
          const cubeBox = new THREE.Box3().setFromObject(cube);

          // Check if the bounding boxes intersect
          return brushBox.intersectsBox(cubeBox);
        }

        function generateShape(shapeId, shapeWidth, shapeHeight) {
          let shape = [[]];
          const basicLength = 40;

          switch (shapeId) {
            case "shape16":
              shape = [
                [0, shapeWidth / 2],
                [0, basicLength / 2],
                [shapeHeight, basicLength / 2],
                [shapeHeight, -basicLength / 2],
                [0, -basicLength / 2],
                [0, -shapeWidth / 2],
                [-shapeHeight, -shapeWidth / 2],
                [-shapeHeight, shapeWidth / 2],
              ];
              break;

            case "shape17":
              shape = [
                [0, shapeWidth / 2],
                [-shapeHeight, shapeWidth / 2],
                [-shapeHeight, basicLength / 2],
                [10, basicLength / 2],
                [10, -basicLength / 2],
                [-shapeHeight, -basicLength / 2],
                [-shapeHeight, -shapeWidth / 2],
                [0, -shapeWidth / 2],
              ];
              break;

            default:
              break;
          }

          console.log("shapepoints: ", shape);

          return createShape(shape);
        }

        function addMoulding(mouldingId, face, options = {}) {
          const defaults = {
            mouldingId: "",
            face: "",
            topDistance: 0,
            shapeId: "",
            shapeWidth: 0,
            shapeHeight: 0,
          };

          const config = {
            ...defaults,
            ...options,
            mouldingId: mouldingId,
            face: face,
          };

          console.log("config: ", config);

          // Get current dimensions
          const { length, width, thickness } = dims;

          // Get shape dims
          let currentShapeDims;
          if (config.shapeId) {
            currentShapeDims = getShapeDimsById(config.shapeId);
          } else {
            currentShapeDims = { width: 0 };
          }

          // Get moulding length
          let mouldingLength = 0;

          // Create a material
          let discMaterial;

          // Calculate position based on face, millimeter coordinates, and dimensions
          const position = [0, 0, 0];
          const rotation = [0, 0, 0];

          // Calculate actual position based on face and millimeter measurements
          switch (face) {
            case FACES.FRONT: // +Z
              // For front face: origin at top-left, X increases right, Y increases down
              position[0] = -width / 2 + config.leftMM;
              position[1] = length / 2 - config.topMM;
              position[2] = thickness / 2 + config.zOffset;
              rotation[0] = Math.PI / 2;

              mouldingLength = 0;
              discMaterial = materials[4];
              break;

            case FACES.BACK: // -Z
              // For back face: origin at top-right (when viewed from behind), X increases left, Y increases down
              position[0] = width / 2 - config.leftMM;
              position[1] = length / 2 - config.topMM;
              position[2] = -thickness / 2 - config.zOffset;
              rotation[0] = -Math.PI / 2;

              mouldingLength = 0;
              discMaterial = materials[5];
              break;

            case FACES.RIGHT: // +X
              // For right face: origin at top-front, X increases toward back, Y increases down
              position[0] = width / 2;
              position[1] = length / 2;
              position[2] =
                -config.topDistance +
                (dims.thickness / 2 - currentShapeDims.width / 2);
              rotation[0] = Math.PI / 2;

              mouldingLength = length;
              discMaterial = materials[0];
              break;

            case FACES.LEFT: // -X
              // For left face: origin at top-back, X increases toward front, Y increases down
              position[0] = -width / 2;
              position[1] = -length / 2;
              position[2] =
                -config.topDistance +
                (dims.thickness / 2 - currentShapeDims.width / 2);
              rotation[0] = -Math.PI / 2;
              rotation[2] = Math.PI;

              mouldingLength = length;
              discMaterial = materials[1];
              break;

            case FACES.TOP: // +Y
              const topLeftMitreCuts = mitreCutsData.filter(
                (item) => item.location === "top-left"
              );
              const topRightMitreCuts = mitreCutsData.filter(
                (item) => item.location === "top-right"
              );

              mouldingLength = width;
              discMaterial = materials[2];

              if (topLeftMitreCuts.length > 0) {
                mouldingLength =
                  (width / Math.cos(topLeftMitreCuts[0].angle)) * 1.2;

                position[0] = width / 2;
                position[1] = length / 2;
                position[2] =
                  -config.topDistance +
                  (dims.thickness / 2 - currentShapeDims.width / 2);

                rotation[0] = Math.PI / 2;
                rotation[1] = -Math.PI / 2 + topLeftMitreCuts[0].angle;
                rotation[2] = Math.PI;
              } else if (topRightMitreCuts.length > 0) {
                mouldingLength =
                  (width / Math.cos(topRightMitreCuts[0].angle)) * 1.2;

                position[0] = -width / 2;
                position[1] = length / 2;
                position[2] =
                  -config.topDistance +
                  (dims.thickness / 2 - currentShapeDims.width / 2);

                rotation[0] = Math.PI / 2;
                rotation[1] = Math.PI / 2 - topRightMitreCuts[0].angle;
              } else {
                position[0] = -width / 2;
                position[1] = length / 2;
                position[2] =
                  -config.topDistance +
                  (dims.thickness / 2 - currentShapeDims.width / 2);

                rotation[1] = Math.PI / 2;
                rotation[2] = Math.PI / 2;
              }
              break;

            case FACES.BOTTOM: // -Y
              const bottomLeftMitreCuts = mitreCutsData.filter(
                (item) => item.location === "bottom-left"
              );
              const bottomRightMitreCuts = mitreCutsData.filter(
                (item) => item.location === "bottom-right"
              );

              if (bottomLeftMitreCuts.length > 0) {
                mouldingLength =
                  (width / Math.cos(bottomLeftMitreCuts[0].angle)) * 1.2;

                position[0] = -width / 2;
                position[1] = -length / 2;
                position[2] =
                  -config.topDistance +
                  (dims.thickness / 2 - currentShapeDims.width / 2);

                rotation[0] = -Math.PI / 2;
                rotation[1] = Math.PI / 2 - bottomLeftMitreCuts[0].angle;
                rotation[2] = 0;
              } else if (bottomRightMitreCuts.length > 0) {
                mouldingLength =
                  (width / Math.cos(bottomRightMitreCuts[0].angle)) * 1.2;

                position[0] = width / 2;
                position[1] = -length / 2;
                position[2] =
                  -config.topDistance +
                  (dims.thickness / 2 - currentShapeDims.width / 2);

                rotation[0] = Math.PI / 2;
                rotation[1] = -Math.PI / 2 - bottomRightMitreCuts[0].angle;
                rotation[2] = 0;
              } else {
                mouldingLength = width;

                position[0] = -width / 2;
                position[1] = -length / 2;
                position[2] =
                  -config.topDistance +
                  (dims.thickness / 2 - currentShapeDims.width / 2);
                rotation[1] = Math.PI / 2;
                rotation[2] = -Math.PI / 2;
              }

              discMaterial = materials[3];
              break;
          }

          const extrudeSettings = {
            steps: 5,
            depth: mouldingLength,
            bevelEnabled: false,
            curveSegments: 200,
          };

          // Generate shape
          const shape = generateShape(
            config.shapeId,
            config.shapeWidth,
            config.shapeHeight
          );

          console.log("shape: ", shape);
          console.log("oldShape", getShapeById(config.shapeId));

          // Create a cylinder geometry with equal top and bottom radius
          const discGeometry = new THREE.ExtrudeGeometry(
            // getShapeById(config.shapeId),
            shape,
            extrudeSettings
          );

          // Create the mesh
          const discMesh = new threeBvhCsg.Brush(discGeometry, discMaterial);
          discMesh.userData.id = mouldingId;

          // Set position
          discMesh.position.set(...position);
          discMesh.rotation.set(...rotation);

          // discMesh.rotation.set(Math.PI / 2, Math.PI / 2 - Math.PI / 6, 0);
          // discMesh.position.set(-width / 2, length / 2, 0);
          discMesh.updateWorldMatrix();

          // Store the disc for later reference
          discs.push({
            id: mouldingId,
            mesh: discMesh,
            face: config.face,
            topDistance: config.topDistance,
            shapeId: config.shapeId,
            shapeWidth: config.shapeWidth,
            shapeHeight: config.shapeHeight,
          });

          const updatedMouldingsData = mouldingData.filter(
            (item) => item.id !== mouldingId
          );
          mouldingData = updatedMouldingsData;
          mouldingData.push({
            id: mouldingId,
            face: config.face,
            topDistance: config.topDistance,
            shapeId: config.shapeId,
          });

          const updatedBrushes = brushes.filter(
            (item) => item.userData.id !== mouldingId
          );
          brushes = updatedBrushes;

          // scene.add(discMesh);

          if (config.shapeWidth > 0 && config.shapeHeight > 0) {
            if (Math.abs(discMesh.position.z) < thickness / 2) {
              brushes.push(discMesh);
            }

            updateCSG();
          }
        }

        function editMoulding(target, value, id) {
          const disc = discs.filter((item) => item.id === id)[0];
          const updateDiscs = discs.filter((item) => item.id !== id);

          switch (target) {
            case "face":
              discs = updateDiscs;

              addMoulding(disc.id, value, {
                topDistance: disc.topDistance,
                shapeId: disc.shapeId,
                shapeWidth: disc.shapeWidth,
                shapeHeight: disc.shapeHeight,
              });

              break;
            case "topDistance":
              discs = updateDiscs;

              addMoulding(disc.id, disc.face, {
                topDistance: parseFloat(value),
                shapeId: disc.shapeId,
                shapeWidth: disc.shapeWidth,
                shapeHeight: disc.shapeHeight,
              });
              break;
            case "shapeId":
              discs = updateDiscs;

              addMoulding(disc.id, disc.face, {
                topDistance: disc.topDistance,
                shapeId: value,
                shapeWidth: disc.shapeWidth,
                shapeHeight: disc.shapeHeight,
              });
              break;

            case "shapeWidth":
              discs = updateDiscs;

              addMoulding(disc.id, disc.face, {
                topDistance: disc.topDistance,
                shapeId: disc.shapeId,
                shapeWidth: parseFloat(value),
                shapeHeight: disc.shapeHeight,
              });
              break;

            case "shapeHeight":
              discs = updateDiscs;

              addMoulding(disc.id, disc.face, {
                topDistance: disc.topDistance,
                shapeId: disc.shapeId,
                shapeWidth: disc.shapeWidth,
                shapeHeight: parseFloat(value),
              });
              break;

            case "shapeDepth":
              discs = updateDiscs;

              addMoulding(disc.id, disc.face, {
                topDistance: disc.topDistance,
                shapeId: disc.shapeId,
                shapeWidth: disc.shapeWidth,
                shapeHeight: disc.shapeHeight,
              });
              break;

            default:
              break;
          }
        }

        function deleteMoulding(id) {
          const updatedItems = discs.filter((item) => item.id === id)[0];
          const updateBrushes = brushes.filter(
            (item) => item !== updatedItems.mesh
          );
          brushes = updateBrushes;

          updateCSG();
        }

        // Add bevel Cut
        function addBevelCut(bevelCutId, options = {}) {
          const defaults = {
            bevelCutId: "",
            edge: "",
            direction: "",
            angle: 0,
          };

          const config = {
            ...defaults,
            ...options,
            bevelCutId: bevelCutId,
          };

          const { length, width, thickness: boxThickness } = dims;

          // Get moulding length
          let bevelCutLength = 0;
          let discMaterial = new THREE.MeshStandardMaterial({});

          let bevelCutDims = { x: 0, y: 0, z: 0 };
          let bevelCutPos = { x: 0, y: 0, z: 0 };
          let bevelCutRot = { x: 0, y: 0, z: 0 };

          let bevelGroupPos = { x: 0, y: 0, z: 0 };
          let bevelGroupRot = { x: 0, y: 0, z: 0 };

          switch (config.edge) {
            case FACES.RIGHT: // +X
              bevelCutLength = length;
              discMaterial = materials[0].clone();

              bevelCutDims.x = boxThickness * 2 * Math.sin(Math.PI / 6);
              bevelCutDims.y = length * 2;
              bevelCutDims.z = (boxThickness * 2) / Math.cos(Math.PI / 6);

              bevelCutPos.x =
                width / 2 + boxThickness / 4 / Math.cos(Math.PI / 6) - 1;

              switch (config.direction) {
                case DIRECTIONS.INWARD:
                  bevelCutRot.y = config.angle;

                  break;

                case DIRECTIONS.OUTWARD:
                  bevelCutRot.y = -config.angle;

                  break;
              }
              break;

            case FACES.LEFT: // -X
              bevelCutLength = length;
              discMaterial = materials[1].clone();

              bevelCutDims.x = boxThickness * 2 * Math.sin(config.angle);
              bevelCutDims.y = length * 2;
              bevelCutDims.z = (boxThickness * 2) / Math.cos(config.angle);

              bevelCutPos.x = -(
                width / 2 +
                boxThickness / 4 / Math.cos(config.angle) -
                1
              );

              switch (config.direction) {
                case DIRECTIONS.INWARD:
                  bevelCutRot.y = config.angle;

                  break;

                case DIRECTIONS.OUTWARD:
                  bevelCutRot.y = -config.angle;

                  break;
              }
              break;

            case FACES.TOP: // +Y
              bevelCutLength = width;
              discMaterial = materials[2].clone();

              bevelCutDims.x = width * 2;
              bevelCutDims.y = boxThickness * 2 * Math.sin(config.angle);
              bevelCutDims.z = (boxThickness * 2) / Math.cos(config.angle);

              bevelCutPos.y =
                length / 2 + boxThickness / 4 / Math.cos(config.angle) - 1;

              const topLeftMitreCuts = mitreCutsData.filter(
                (item) => item.location === "top-left"
              );
              const topRightMitreCuts = mitreCutsData.filter(
                (item) => item.location === "top-right"
              );
              if (topLeftMitreCuts.length > 0) {
                bevelGroupRot.z = topLeftMitreCuts[0].angle;
                bevelGroupPos.y =
                  (width / 2 / Math.cos(topLeftMitreCuts[0].angle)) *
                  Math.sin(topLeftMitreCuts[0].angle);
              } else if (topRightMitreCuts.length > 0) {
                bevelGroupRot.z = -topRightMitreCuts[0].angle;
                bevelGroupPos.y =
                  (width / 2 / Math.cos(topRightMitreCuts[0].angle)) *
                  Math.sin(topRightMitreCuts[0].angle);
              }

              switch (config.direction) {
                case DIRECTIONS.INWARD:
                  bevelCutRot.x = config.angle;
                  bevelCutRot.y = 0;
                  bevelCutRot.z = 0;

                  break;

                case DIRECTIONS.OUTWARD:
                  bevelCutRot.x = -config.angle;
                  bevelCutRot.y = 0;
                  bevelCutRot.z = 0;

                  break;
              }
              break;

            case FACES.BOTTOM: // -Y
              bevelCutLength = width;
              discMaterial = materials[3].clone();

              bevelCutDims.x = width * 2;
              bevelCutDims.y = boxThickness * 2 * Math.sin(Math.PI / 6);
              bevelCutDims.z = (boxThickness * 2) / Math.cos(Math.PI / 6);

              bevelCutPos.y = -(
                length / 2 +
                boxThickness / 4 / Math.cos(Math.PI / 6) -
                1
              );

              const bottomLeftMitreCuts = mitreCutsData.filter(
                (item) => item.location === "bottom-left"
              );
              const bottomRightMitreCuts = mitreCutsData.filter(
                (item) => item.location === "bottom-right"
              );
              if (bottomLeftMitreCuts.length > 0) {
                bevelGroupRot.z = bottomLeftMitreCuts[0].angle;
                bevelGroupPos.y =
                  -(width / 2 / Math.cos(bottomLeftMitreCuts[0].angle)) *
                  Math.sin(bottomLeftMitreCuts[0].angle);
              } else if (bottomRightMitreCuts.length > 0) {
                bevelGroupRot.z = -bottomRightMitreCuts[0].angle;
                bevelGroupPos.y =
                  -(width / 2 / Math.cos(bottomRightMitreCuts[0].angle)) *
                  Math.sin(bottomRightMitreCuts[0].angle);
              }

              switch (config.direction) {
                case DIRECTIONS.INWARD:
                  bevelCutRot.x = config.angle;
                  bevelCutRot.y = 0;
                  bevelCutRot.z = 0;

                  break;

                case DIRECTIONS.OUTWARD:
                  bevelCutRot.x = -config.angle;
                  bevelCutRot.y = 0;
                  bevelCutRot.z = 0;

                  break;
              }
              break;
          }

          const discGeometry = new THREE.BoxGeometry(
            bevelCutDims.x,
            bevelCutDims.y,
            bevelCutDims.z
          );

          const discMesh = new threeBvhCsg.Brush(discGeometry, discMaterial);

          const group = new THREE.Group();
          group.add(discMesh);
          group.position.set(
            bevelCutPos.x,
            bevelCutPos.y - bevelGroupPos.y,
            bevelCutPos.z
          );

          group.rotation.set(0, 0, bevelGroupRot.z);

          group.updateMatrixWorld(true);

          discMesh.rotation.set(bevelCutRot.x, bevelCutRot.y, bevelCutRot.z);

          if (
            config.direction !== "" &&
            config.edge !== "" &&
            config.angle !== 0
          ) {
            discs.push({
              id: bevelCutId,
              mesh: discMesh,
              edge: config.edge,
              direction: config.direction,
              angle: config.angle,
            });

            const updatedBevelCutsData = bevelCutsData.filter(
              (item) => item.id !== bevelCutId
            );
            bevelCutsData = updatedBevelCutsData;
            bevelCutsData.push({
              id: bevelCutId,
              edge: config.edge,
              direction: config.direction,
              angle: config.angle,
            });

            const updatedBrushes = brushes.filter(
              (item) => item.userData.id !== bevelCutId
            );
            brushes = updatedBrushes;

            // scene.add(group);

            group.traverse((child) => {
              if (child.isMesh && child.geometry) {
                child.updateWorldMatrix(true, false);

                const geometry = child.geometry.clone();
                geometry.applyMatrix4(child.matrixWorld);

                const mesh = new threeBvhCsg.Brush(
                  geometry,
                  child.material.clone()
                );
                mesh.userData.id = bevelCutId;

                brushes.push(mesh);
              }
            });

            updateCSG();
          }
        }

        // Edit Bevel Cut
        function editBevelCut(bevelCutId, options = {}) {
          addBevelCut(bevelCutId, { ...options });
        }

        // Remove Bevel Cut
        function deleteBevelCut(bevelCutId) {
          const updatedBrushes = brushes.filter(
            (item) => item.userData.id !== bevelCutId
          );
          brushes = updatedBrushes;

          updateCSG();
        }

        // Add Mitre Cut
        function addMitreCut(mitreCutId, options = {}) {
          const defaults = {
            mitreCutId: "",
            location: "",
            angle: 0,
          };

          const config = {
            ...defaults,
            ...options,
            mitreCutId: mitreCutId,
          };

          const { length, width, thickness: boxThickness } = dims;

          // Get moulding length
          let mitreCutPos = { x: 0, y: 0, z: 0 };
          let mitreCutRot = { x: 0, y: 0, z: 0 };

          switch (config.location) {
            case LOCATIONS.TOPLEFTCORNER:
              mitreCutPos.y = length / 2 - 0.01;
              mitreCutRot.z = config.angle;
              break;

            case LOCATIONS.TOPRIGHTCORNER:
              mitreCutPos.y = length / 2 - 0.01;
              mitreCutRot.z = -config.angle;

              break;

            case LOCATIONS.BOTTOMLEFTCORNER:
              mitreCutPos.y = -length / 2 + 0.01;
              mitreCutRot.z = config.angle;

              break;

            case LOCATIONS.BOTTOMRIGHTCORNER:
              mitreCutPos.y = -length / 2 + 0.01;
              mitreCutRot.z = -config.angle;

              break;
          }

          const discGeometry = new THREE.BoxGeometry(
            (width * 2) / Math.cos(config.angle),
            width * Math.cos(Math.PI / 2 - config.angle),
            boxThickness
          );

          // Create a material
          let discMaterial = new THREE.MeshStandardMaterial();

          switch (config.location) {
            case LOCATIONS.TOPLEFTCORNER: // +Y
              discMaterial = materials[2].clone();
              break;

            case LOCATIONS.TOPRIGHTCORNER: // +Y
              discMaterial = materials[2].clone();
              break;

            case LOCATIONS.BOTTOMLEFTCORNER: // -Y
              discMaterial = materials[3].clone();
              break;

            case LOCATIONS.BOTTOMRIGHTCORNER: // -Y
              discMaterial = materials[3].clone();
              break;
          }

          const discMesh = new threeBvhCsg.Brush(discGeometry, discMaterial);

          discMesh.userData.id = mitreCutId;
          discMesh.rotation.set(mitreCutRot.x, mitreCutRot.y, mitreCutRot.z);
          discMesh.position.set(mitreCutPos.x, mitreCutPos.y, mitreCutPos.z);

          discMesh.updateWorldMatrix();

          if (config.angle !== 0 && config.direction !== "") {
            discs.push({
              id: mitreCutId,
              mesh: discMesh,
              location: config.location,
              angle: config.angle,
            });

            const updatedMitreCuts = mitreCutsData.filter(
              (item) => item.id !== mitreCutId
            );
            mitreCutsData = updatedMitreCuts;
            mitreCutsData.push({
              id: mitreCutId,
              location: config.location,
              angle: config.angle,
            });

            const updatedBrushes = brushes.filter(
              (item) => item.userData.id !== mitreCutId
            );
            brushes = updatedBrushes;

            brushes.push(discMesh);
            updateCSG();
          }
        }

        // Edit Mitre Cut
        function editMitreCut(mitreCutId, options = {}) {
          addMitreCut(mitreCutId, { ...options });
          updateCSGMeshes("moulding");
          updateCSGMeshes("bevelCut");
        }

        // Remove Mitre Cut
        function deleteMitreCut(mitreCutId) {
          const updatedBrushes = brushes.filter(
            (item) => item.userData.id !== mitreCutId
          );
          brushes = updatedBrushes;

          updateCSG();
        }

        // Return public API
        return {
          init: init,
          changeModelSize: changeModelSize,
          updateFaceTexture: updateFaceTexture,
          addLabelsToBox: addLabelsToBox,
          addThickCircle: addThickCircle,
          editThickCircle: editThickCircle,
          deleteThickCircle: deleteThickCircle,
          updateCameraPosition: updateCameraPosition,
          getScene: () => scene,
          getCamera: () => camera,
          getControls: () => controls,
          getCube: () => cube,
          getDimensions: () => ({ ...dims }),
          getMaterials: () => [...materials],
          FACES: FACES, // Export face
          addMoulding: addMoulding,
          editMoulding: editMoulding,
          deleteMoulding: deleteMoulding,
          addBevelCut: addBevelCut,
          editBevelCut: editBevelCut,
          deleteBevelCut: deleteBevelCut,
          DIRECTIONS: DIRECTIONS,
          addMitreCut: addMitreCut,
          editMitreCut: editMitreCut,
          deleteMitreCut: deleteMitreCut,
        };
      })();

      // Export BoxModel to the global scope so it can be accessed from the console
      globalThis.BoxModel = BoxModel;

      // Example usage from console:
      // BoxModel.updateFaceTexture(BoxModel.FACES.TOP, "/path/to/texture.jpg");

      // Initialize the model when the document is ready
      document.addEventListener("DOMContentLoaded", BoxModel.init);

      document.getElementById("model-width").addEventListener("change", (e) => {
        BoxModel.changeModelSize(
          BoxModel.getDimensions().length,
          parseFloat(e.target.value),
          BoxModel.getDimensions().thickness
        );
      });
      document
        .getElementById("model-length")
        .addEventListener("change", (e) => {
          BoxModel.changeModelSize(
            parseFloat(e.target.value),
            BoxModel.getDimensions().width,
            BoxModel.getDimensions().thickness
          );
        });
      document
        .getElementById("model-thickness")
        .addEventListener("change", (e) => {
          BoxModel.changeModelSize(
            BoxModel.getDimensions().length,
            BoxModel.getDimensions().width,
            parseFloat(e.target.value)
          );
        });

      document
        .getElementById("add-moulding-btn")
        .addEventListener("click", function () {
          const container = document.getElementById("mouldings-container");

          // Generate moulding Id
          const mouldingId =
            Date.now().toString() + Math.random().toString(36).substr(2, 9);

          // Create a new moulding item
          const newItem = document.createElement("div");
          newItem.classList.add("moulding-item");
          newItem.dataset.mouldingId = mouldingId; // Unique ID

          newItem.innerHTML = `
          <div class="input-group mb-2">
              <select class="form-select moulding-face" onchange="BoxModel.editMoulding('face', this.value, this.closest('.moulding-item').dataset.mouldingId)">
                  <option value="left">Left</option>
                  <option value="right">Right</option>
                  <option value="top">Top</option>
                  <option value="bottom">Bottom</option>
              </select>
              <input type="number" placeholder="Distance from Top" class="form-control moulding-distance"  onchange="BoxModel.editMoulding('topDistance', this.value, this.closest('.moulding-item').dataset.mouldingId)"/>
              <select class="form-select moulding-shape" onchange="BoxModel.editMoulding('shapeId', this.value, this.closest('.moulding-item').dataset.mouldingId)">
                  <option value="">None</option>
                  <option value="shape16">Shape 16</option>
                  <option value="shape17">Shape 17</option>
              </select>
              <input type="number" placeholder="Shape Width" class="form-control shape-width"  onchange="BoxModel.editMoulding('shapeWidth', this.value, this.closest('.moulding-item').dataset.mouldingId)"/>
              <input type="number" placeholder="Shape Height" class="form-control shape-height"  onchange="BoxModel.editMoulding('shapeHeight', this.value, this.closest('.moulding-item').dataset.mouldingId)"/>
              <button onclick="BoxModel.deleteMoulding(this.closest('.moulding-item').dataset.mouldingId)" type="button" class="btn btn-danger remove-moulding" id="delete-moulding-btn">
                  Delete
              </button>
          </div>
      `;

          // Append new item to container
          container.appendChild(newItem);

          // Add moulding data
          BoxModel.addMoulding(mouldingId, BoxModel.FACES.LEFT, {});
        });

      // Event delegation for removing items
      document
        .getElementById("mouldings-container")
        .addEventListener("click", function (e) {
          // If the clicked element is the delete button, remove the corresponding moulding item
          if (e.target && e.target.id === "delete-moulding-btn") {
            const mouldingItem = e.target.closest(".moulding-item");
            if (mouldingItem) {
              mouldingItem.remove();
            }
          }
        });

      const cutoutsContainer = document.getElementById("cutouts-container"),
        holesInput = document.getElementById("cutout-holes-data"),
        cutoutCircles = {},
        DEFAULT_CUTOUT = { top: 100, left: 100, diameter: 30 };

      function getThickness() {
        return parseInt(document.getElementById("thickness")?.value) || 60;
      }

      function getData(item) {
        return {
          top: +item.querySelector(".cutout-top").value || 0,
          left: +item.querySelector(".cutout-left").value || 0,
          diameter: +item.querySelector(".cutout-diameter").value || 30,
        };
      }

      function updateHoles() {
        holesInput.value = JSON.stringify(
          [...container.querySelectorAll(".cutout-item")].map(getData)
        );
      }

      function renderCircle(id, data) {
        const radius = data.diameter / 2,
          thickness = getThickness();
        cutoutCircles[id] = BoxModel.addThickCircle(radius, thickness, {
          face: BoxModel.FACES.FRONT,
          zOffset: -(thickness / 2),
          topMM: data.top,
          leftMM: data.left,
          color: 0xff0000,
          opacity: 0.7,
        });
      }

      function removeCircle(id) {
        BoxModel.deleteThickCircle(cutoutCircles[id]);
        delete cutoutCircles[id];
      }

      function addCutout(data = DEFAULT_CUTOUT) {
        const id = Date.now().toString();
        cutoutsContainer.insertAdjacentHTML(
          "beforeend",
          `
                <div class="cutout-item" data-cutout-id="${id}">
                    <div class="input-group mb-2">
                        <input type="number" placeholder="Top" value="${data.top}" class="cutout-top form-control">
                        <input type="number" placeholder="Left" value="${data.left}" class="cutout-left form-control">
                        <select class="form-select cutout-diameter">
                            <option value="60">60mm</option>
                            <option value="40">40mm</option>
                        </select>
                        <button type="button" class="btn btn-danger remove-cutout">Delete</button>
                    </div>
                </div>
            `
        );
        renderCircle(id, data);
        updateHoles();
      }

      document.addEventListener("DOMContentLoaded", () => {
        try {
          JSON.parse(holesInput.value || "[]").forEach((cutout, idx) =>
            renderCircle(idx.toString(), cutout)
          );
        } catch (e) {
          console.error(e);
        }

        document.getElementById("add-cutout-btn").onclick = () => addCutout();

        cutoutsContainer.addEventListener("click", (e) => {
          if (e.target.closest(".remove-cutout")) {
            const item = e.target.closest(".cutout-item");
            removeCircle(item.dataset.cutoutId);
            item.remove();
            updateHoles();
          }
        });

        cutoutsContainer.addEventListener("change", (e) => {
          if (
            ["cutout-top", "cutout-left", "cutout-diameter"].some((cls) =>
              e.target.classList.contains(cls)
            )
          ) {
            const item = e.target.closest(".cutout-item");
            removeCircle(item.dataset.cutoutId);
            renderCircle(item.dataset.cutoutId, getData(item));
            updateHoles();
          }
        });
      });

      const bevelcutsContainer = document.getElementById("bevels-container");

      function addBevelcut() {
        // Generate moulding Id
        const bevelCutId =
          Date.now().toString() + Math.random().toString(36).substr(2, 9);

        // Create a new moulding item
        const newItem = document.createElement("div");
        newItem.classList.add("bevel-cut-item");
        newItem.dataset.bevelCutId = bevelCutId; // Unique ID

        newItem.innerHTML = `
          <div class="input-group mb-2">
              <select class="form-select cut-location" id="bevel-location">
                  <option value="">Edge</option>
                  <option value="top">Top Edge</option>
                  <option value="left">Left Edge</option>
                  <option value="right">Right Edge</option>
                  <option value="bottom">Bottom Edge</option>
              </select>
              <select class="form-select cut-direction" id="bevel-direction">
                  <option value="">Direction</option>
                  <option value="inward">Inward</option>
                  <option value="outward">Outward</option>
              </select>
              <select class="form-select cut-angle" id="bevel-angle">
                  <option value="">Angle</option>
                  <option value="15">15</option>
                  <option value="22.5">22.5</option>
                  <option value="30">30</option>
                  <option value="45">45</option>
              </select>
              <button type="button" class="btn btn-danger remove-bevel-cut" id="delete-moulding-btn">
                  Delete
              </button>
          </div>
      `;

        // Append new item to container
        bevelcutsContainer.appendChild(newItem);

        const defaultValues = {
          edge: "",
          direction: "",
          angle: 0,
        };

        BoxModel.addBevelCut(bevelCutId, defaultValues);
      }

      document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("add-bevelcut-btn").onclick = () =>
          addBevelcut();

        bevelcutsContainer.addEventListener("click", (e) => {
          if (e.target.closest(".remove-bevel-cut")) {
            const item = e.target.closest(".bevel-cut-item");
            const bevelCutId = item.dataset.bevelCutId;

            BoxModel.deleteBevelCut(bevelCutId);

            item.remove();
          }
        });

        bevelcutsContainer.addEventListener("change", (e) => {
          if (
            ["cut-location", "cut-direction", "cut-angle"].some((cls) =>
              e.target.classList.contains(cls)
            )
          ) {
            const item = e.target.closest(".bevel-cut-item");

            const bevelCutId = item.dataset.bevelCutId;
            const bevelLocation = item.querySelector(".cut-location")?.value;
            const bevelDirection = item.querySelector(".cut-direction")?.value;
            const bevelAngle = item.querySelector(".cut-angle")?.value;

            BoxModel.editBevelCut(bevelCutId, {
              edge: bevelLocation,
              direction: bevelDirection,
              angle: (bevelAngle * Math.PI) / 180,
            });
          }
        });
      });

      const mitreCutContainer = document.getElementById("mitre-cut-container");

      function addMitreCut() {
        // Generate moulding Id
        const mitreCutId =
          Date.now().toString() + Math.random().toString(36).substr(2, 9);

        // Create a new moulding item
        const newItem = document.createElement("div");
        newItem.classList.add("mitre-cut-item");
        newItem.dataset.mitreCutId = mitreCutId; // Unique ID

        newItem.innerHTML = `
          <div class="input-group mb-2">
              <select class="form-select cut-location" id="mitre-location">
                  <option value="">Corner</option>
                  <option value="top-left">Top Left Corner</option>
                  <option value="top-right">Top Right Corner</option>
                  <option value="bottom-left">Bottom Left Corner</option>
                  <option value="bottom-right">Bottom Right Corner</option>
              </select>
              <select class="form-select cut-angle">
                  <option value="">Angle</option>
                  <option value="15">15</option>
                  <option value="22.5">22.5</option>
                  <option value="30">30</option>
                  <option value="45">45</option>
              </select>
              <button type="button" class="btn btn-danger remove-mitre-cut" id="delete-moulding-btn">
                  Delete
              </button>
          </div>
      `;

        // Append new item to container
        mitreCutContainer.appendChild(newItem);

        const defaultValues = {
          location: "",
          angle: 0,
        };

        BoxModel.addMitreCut(mitreCutId, defaultValues);
      }

      document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("add-mitrecut-btn").onclick = () =>
          addMitreCut();

        mitreCutContainer.addEventListener("click", (e) => {
          if (e.target.closest(".remove-mitre-cut")) {
            const item = e.target.closest(".mitre-cut-item");
            const mitreCutId = item.dataset.mitreCutId;

            BoxModel.deleteMitreCut(mitreCutId);

            item.remove();
          }
        });

        mitreCutContainer.addEventListener("change", (e) => {
          if (
            ["cut-location", "cut-angle"].some((cls) =>
              e.target.classList.contains(cls)
            )
          ) {
            const item = e.target.closest(".mitre-cut-item");

            const mitreCutId = item.dataset.mitreCutId;
            const mitreLocation = item.querySelector(".cut-location")?.value;
            const mitreAngle = item.querySelector(".cut-angle")?.value;

            BoxModel.editMitreCut(mitreCutId, {
              location: mitreLocation,
              angle: (mitreAngle * Math.PI) / 180,
            });
          }
        });
      });
    </script>
  </body>
</html>
